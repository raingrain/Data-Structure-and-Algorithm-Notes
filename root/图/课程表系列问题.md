# 课程表系列问题

## [207. 课程表](https://leetcode.cn/problems/course-schedule/)

> - ***Question 1***
>   - 你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。
>   - 在选修某些课程之前需要一些先修课程。先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则必须先学习课 `bi` 。
>   - 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。
>   - 请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。
>   - ***tips:***
>     - `1 <= numCourses <= 10^5`
>     - `0 <= prerequisites.length <= 5000`
>     - `prerequisites[i].length == 2`
>     - `0 <= ai, bi < numCourses`
>     - `prerequisites[i]` 中的所有课程对互不相同

## [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

## [剑指 Offer II 113. 课程顺序](https://leetcode.cn/problems/QA2IGt/)

> - ***Question 2***
>   - 你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。
>   - 在选修某些课程之前需要一些先修课程。先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则必须先学习课 `bi` 。
>   - 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。
>   - 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回任意一种 就可以了。如果不可能完成所有课程，返回一个空数组。
>   - ***tips:***
>     - `1 <= numCourses <= 2000`
>     - `0 <= prerequisites.length <= numCourses * (numCourses - 1)`
>     - `prerequisites[i].length == 2`
>     - `0 <= ai, bi < numCourses`
>     - `ai != bi`
>     - 所有 `[ai, bi]` 互不相同

---

## *Java*

> - ***Question 1: 拓扑排序可行性检验***

```java
class Solution {
    
    // 图节点
    public static class Course {
        
        // 课程编号
        public int name;
        // 入度
        public int in;
        // 下一级课程
        public ArrayList<Course> nexts;
        
        public Course(int name, int in) {
            this.name = name;
            this.in = in;
            this.nexts = new ArrayList<>();
        }
        
    }
    
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if (prerequisites == null || prerequisites.length == 0) {
            return true;
        }
        // key为课程编号，value为对应图节点
        // 构成一张有向图
        HashMap<Integer, Course> courseMap = new HashMap<>();
        for (int[] arr : prerequisites) {
            // 先修课程->后修课程
            int from = arr[1];
            int to = arr[0];
            // 没有就建立节点
            if (!courseMap.containsKey(from)) {
                courseMap.put(from, new Course(from, 0));
            }
            if (!courseMap.containsKey(to)) {
                courseMap.put(to, new Course(to, 0));
            }
            // from指向to
            courseMap.get(from).nexts.add(courseMap.get(to));
            // to入度+1
            courseMap.get(to).in++;
        }
        // 入度为0的节点才能进入队列
        ArrayDeque<Course> zeroInQueue = new ArrayDeque<>();
        // 队列初始化，先将图最外圈节点删除
        for (Course course : courseMap.values()) {
            if (course.in == 0) {
                zeroInQueue.offer(course);
            }
        }
        // 统计有多少元素出队
        int count = 0;
        while (!zeroInQueue.isEmpty()) {
            // 出队，答案++
            Course curCourse = zeroInQueue.poll();
            count++;
            // 将其指向的下一级节点的入度-1，并且-1后为0的入队
            for (Course nextCourse : curCourse.nexts) {
                if (--nextCourse.in == 0) {
                    zeroInQueue.offer(nextCourse);
                }
            }
        }
        // 出队数等于图中课程数才算完成拓扑排序
        // 有循环依赖将有节点留在队列中
        return count == courseMap.size();
    }
    
}
```

> - ***Question 2: 拓扑排序可行性检验***

```java
class Solution {
    
    public static class Course {
        
        public int name;
        public int in;
        public ArrayList<Course> nexts;
        
        public Course(int name, int in) {
            this.name = name;
            this.in = in;
            this.nexts = new ArrayList<>();
        }
        
    }
    
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 这里开始考虑既不依赖其他课程，也没有被其他课程依赖的课
        int[] ans = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            ans[i] = i;
        }
        if (prerequisites == null || prerequisites.length == 0) {
            // 没有依赖关系，按顺序上就行
            return ans;
        }
        HashMap<Integer, Course> courseMap = new HashMap<>();
        for (int[] arr : prerequisites) {
            int from = arr[1];
            int to = arr[0];
            if (!courseMap.containsKey(from)) {
                courseMap.put(from, new Course(from, 0));
            }
            if (!courseMap.containsKey(to)) {
                courseMap.put(to, new Course(to, 0));
            }
            courseMap.get(from).nexts.add(courseMap.get(to));
            courseMap.get(to).in++;
        }
        // 填ans的指针
        int index = 0;
        ArrayDeque<Course> zeroInQueue = new ArrayDeque<>();
        for (int i = 0; i < numCourses; i++) {
            if (!courseMap.containsKey(i)) {
                // 不在图中说明课程独立
                // 可以先上
                ans[index++] = i;
            } else if (courseMap.get(i).in == 0) {
                // 入度为0入队
                zeroInQueue.offer(courseMap.get(i));
            }
        }
        int count = 0;
        while (!zeroInQueue.isEmpty()) {
            Course curCourse = zeroInQueue.poll();
            // 弹出时统计答案
            ans[index++] = curCourse.name;
            count++;
            for (Course nextCourse : curCourse.nexts) {
                if (--nextCourse.in == 0) {
                    zeroInQueue.offer(nextCourse);
                }
            }
        }
        // 不能拓扑返回空数组
        return count == courseMap.size() ? ans : new int[0];
    }
    
}
```

---

> ***last change: 2023/4/18***

---
