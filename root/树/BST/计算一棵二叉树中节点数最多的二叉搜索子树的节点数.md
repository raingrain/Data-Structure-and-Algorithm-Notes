# 计算一棵二叉树中节点数最多的二叉搜索子树的节点数

## 程序员代码面试指南：IT名企算法与数据结构题目最优解（第二版） 第3章 二叉树问题 找到二叉树中的最大搜索二叉子树

> - ***Question***
>   - 给定一棵二叉树的头节点 `root` ，已知其中所有节点的值都不一样，找到含有节点最多的搜索二叉子树，并返回这棵子树的头节点

---

## *Java*

> - ***树形DP***
>   - 以节点X为头节点的子树中，最大的搜索二叉子树只可能是以下三种情况中可能性最大的那种：
>     - 第一种： `X` 为头节点的子树中，最大的搜索二叉子树就是 `X` 的左子树中的最大搜索二叉子树，即答案可能来自左子树
>     - 第二种： `X` 为头节点的子树中，最大的搜索二叉子树就是 `X` 的右子树中的最大搜索二叉子树，即答案可能来自右子树
>     - 第三种：如果 `X` 左子树上的最大搜索二叉子树是 `X` 左子树的全体， `X` 右子树上的最大搜索二叉子树是 `X` 右子树的全体，并且 `X` 的值大于 `X` 左子树所有节点的最大值，但小于 `X` 右子树所有节点的最小值，那么 `X` 为头节点的子树中，最大的搜索二叉子树就是以 `X` 为头节点的全体，即答案可能是用 `X` 连起所有
>   - 据此构建信息类 `Info`，然后设计递归函数
>   - 节点数为 `N` ，则时间复杂度为 `O(N)` ，额外空间复杂度为 `O(h)` ， `h` 为二叉树的高度

```java
class TreeNode {
    
    int val;
    TreeNode left;
    TreeNode right;
    
    TreeNode() {}
    
    TreeNode(int val) {this.val = val;}
    
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
    
}

class Solution {
    
    // 信息类
    static class Info {
        
        // 当maxBSSTSize与size相等时，整棵树是搜索二叉树，否则不是，这样省略了一个isBST变量
        // 以我为头的整棵树中的节点最多的二叉搜索子树的节点数
        public int maxBSSTSize;
        // 以我为头的树的节点数
        public int size;
        // 树的最大值与最小值
        public int max;
        public int min;
        
        public Info(int maxBSSTSize, int size, int max, int min) {
            this.maxBSSTSize = maxBSSTSize;
            this.size = size;
            this.max = max;
            this.min = min;
        }
        
    }
    
    public int getMaxBSSTSize(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return getMaxBSSTSizeByRecursion(root).maxBSSTSize;
    }
    
    public Info getMaxBSSTSizeByRecursion(TreeNode root) {
        // 空的情况下最值不好设置，交给上游处理
        if (root == null) {
            return null;
        }
        Info leftInfo = getMaxBSSTSizeByRecursion(root.left);
        Info rightInfo = getMaxBSSTSizeByRecursion(root.right);
        
        // 构建root的信息类所需要的信息
        // 最值初始值为root.val
        // 左右子树如果不为空，就去更新一下最值
        int max = root.val;
        int min = root.val;
        // 因为root不等于空，那么初始节点数为1
        // 如果左右子树不为空，再加上左右子树
        int size = 1;
        
        // 左树节点数，空时节点数为0
        int leftTreeSize = 0;
        // p1，最大二叉搜索子树出现在左树上
        int leftTreeMaxBSSTSize = -1;
        // 左树是不是二叉搜索树，空树是搜索二叉树
        boolean leftTreeIsBST = true;
        // 左树的最大值小不小于root的值，空树不影响大小关系
        boolean isLeftTreeMaxLessRoot = true;
        if (leftInfo != null) {
            max = Math.max(max, leftInfo.max);
            min = Math.min(min, leftInfo.min);
            size += leftInfo.size;
            leftTreeSize = leftInfo.size;
            leftTreeMaxBSSTSize = leftInfo.maxBSSTSize;
            // 当最大二叉搜索子树的节点数量等于整棵树的节点数量时，整棵树就是二叉搜索子树
            leftTreeIsBST = leftInfo.maxBSSTSize == leftInfo.size;
            isLeftTreeMaxLessRoot = leftInfo.max < root.val;
        }
        
        // 右树节点数，空时节点数为0
        int rightTreeSize = 0;
        // p2，最大二叉搜索子树出现在右树上
        int rightTreeMaxBSSTSize = -1;
        // 右树是不是二叉搜索树，空树是搜索二叉树
        boolean rightTreeIsBST = true;
        // 右树的最小值大不大于root的值，空树不影响大小关系
        boolean isRightTreeMinMoreRoot = true;
        if (rightInfo != null) {
            max = Math.max(max, rightInfo.max);
            min = Math.min(min, rightInfo.min);
            size += rightInfo.size;
            rightTreeSize = rightInfo.size;
            rightTreeMaxBSSTSize = rightInfo.maxBSSTSize;
            // 当最大二叉搜索子树的节点数量等于整棵树的节点数量时，整棵树就是二叉搜索子树
            rightTreeIsBST = rightInfo.maxBSSTSize == rightInfo.size;
            isRightTreeMinMoreRoot = rightInfo.min > root.val;
        }
        
        // p3，最大二叉搜索子树就是以root为头节点的树本身
        int p3 = -1;
        // 左右子树都是二叉搜索树且对root满足大小关系，计算节点数量
        if (leftTreeIsBST && rightTreeIsBST && isLeftTreeMaxLessRoot && isRightTreeMinMoreRoot) {
            p3 = leftTreeSize + rightTreeSize + 1;
        }
        
        return new Info(Math.max(p3, Math.max(leftTreeMaxBSSTSize, rightTreeMaxBSSTSize)), size, max, max);
    }
    
}
```

---

> ***last change: 2022/10/25***

---
