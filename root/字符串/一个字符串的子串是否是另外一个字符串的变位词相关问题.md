# 一个字符串的子串是否是另外一个字符串的变位词相关问题

## [567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

## [剑指 Offer II 014. 字符串中的变位词](https://leetcode.cn/problems/MPnaiL/)

> - ***Question 1***
>   - 给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的排列。如果是，返回 `true` ；否则，返回 `false` 。
>   - 换句话说 `s1` 的排列之一是 `s2` 的子串 。
>   - ***tips:***
>     - `1 <= s1.length, s2.length <= 10^4`
>     - `s1` 和 `s2` 仅包含小写字母

## [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

## [剑指 Offer II 032. 有效的变位词](https://leetcode.cn/problems/dKk3P7/)

> - ***Question 2***
>   - 给定两个字符串 `s1` 和 `s2` ，编写一个函数来判断它们是不是一组变位词（字母异位词）。
>   - 注意：若 `s1` 和 `s2` 中每个字符出现的次数都相同且字符顺序不完全相同，则称 `s1` 和 s2` 互为变位词（字母异位词）。当然也有定义不要求字符顺序不完全相同。
>   - ***tips:***
>     - `1 <= s1.length, s2.length <= 5 * 10^4`
>     - `s1` 和 `s2` 仅包含小写字母

## [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

## [剑指 Offer II 015. 字符串中的所有变位词](https://leetcode.cn/problems/VabMRr/)

> - ***Question 3***
>   - 给定两个字符串 `s1` 和 `s2` ，找到 `s2` 中所有 `s1` 的异位词的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
>   - 异位词指由相同字母重排列形成的字符串（包括相同的字符串）。
>   - ***tips:***
>     - `1 <= s1.length, s2.length <= 3 * 10^4`
>     - `s1` 和 `s2` 仅包含小写字母

---

## *Java*

> - ***Question 1: 滑动窗口 + 哈希表***

```java
class Solution {
    
    public boolean checkInclusion(String s1, String s2) {
        if (s2.length() < s1.length()) {
            // s2是大的，长度一定要大于等于s1的
            return false;
        }
        char[] str1 = s1.toCharArray();
        char[] str2 = s2.toCharArray();
        // 生成str1的词频表，因为题目要求全是小写字母，长度为26
        int[] count = new int[26];
        for (char c : str1) {
            count[c - 'a']++;
        }
        // str1一共有几个数字
        int all = str1.length;
        // 滑动窗口右边界
        int right = 0;
        // 规则，进窗口的数字，对应词频表--，如果减完后的词频是一个非负数，all也减1
        // 出窗口的数字，对应词频表++，如果加完后的词频是一个正数，all也加1
        // 当窗口形成且此时all等于0时，找到一组变为词
        // 先生成初始窗口str2[0~str1.length - 1]
        for (; right < str1.length; right++) {
            if (count[str2[right] - 'a']-- > 0) {
                all--;
            }
        }
        // 窗口移动
        for (; right < str2.length; right++) {
            // 每次循环生成一个新的窗口，但这个新的窗口的判断要在下一轮循环中进行
            if (all == 0) {
                return true;
            }
            // 按照规则对表做相应修改
            if (count[str2[right] - 'a']-- > 0) {
                all--;
            }
            if (count[str2[right - str1.length] - 'a']++ >= 0) {
                all++;
            }
        }
        // 最后一个窗口也需要判断
        return all == 0;
    }
    
}
```

> - ***Question 2: 滑动窗口 + 哈希表***

```java
class Solution {
    
    public List<Integer> findAnagrams(String s2, String s1) {
        List<Integer> ans = new ArrayList<>();
        if (s2.length() < s1.length()) {
            // 返回空表
            return ans;
        }
        char[] str1 = s1.toCharArray();
        char[] str2 = s2.toCharArray();
        int[] count = new int[26];
        for (char c : str1) {
            count[c - 'a']++;
        }
        int all = str1.length;
        int right = 0;
        for (; right < str1.length; right++) {
            if (count[str2[right] - 'a']-- > 0) {
                all--;
            }
        }
        for (; right < str2.length; right++) {
            if (all == 0) {
                // 注意，此时窗口右边界和长度知道，返回左边界
                ans.add(right - str1.length);
            }
            if (count[str2[right] - 'a']-- > 0) {
                all--;
            }
            if (count[str2[right - str1.length] - 'a']++ >= 0) {
                all++;
            }
        }
        // 最后判断
        if (all == 0) {
            ans.add(right - str1.length);
        }
        return ans;
    }
    
}
```

> - ***Question 3: 滑动窗口 + 哈希表***
>   - 直接调用 `Question 1` 即可。

```java
class Solution {
    
    public boolean checkInclusion(String s1, String s2) {
        if (s2.length() < s1.length()) {
            return false;
        }
        char[] str1 = s1.toCharArray();
        char[] str2 = s2.toCharArray();
        int[] count = new int[26];
        for (char c : str1) {
            count[c - 'a']++;
        }
        int all = str1.length;
        int right = 0;
        for (; right < str1.length; right++) {
            if (count[str2[right] - 'a']-- > 0) {
                all--;
            }
        }
        for (; right < str2.length; right++) {
            if (all == 0) {
                return true;
            }
            if (count[str2[right] - 'a']-- > 0) {
                all--;
            }
            if (count[str2[right - str1.length] - 'a']++ >= 0) {
                all++;
            }
        }
        return all == 0;
    }
    
    public boolean isAnagram(String s, String t) {
        // 注意 || s.length() == 1是为了避免顺序不能相同的要求，只有一个字符时顺序必然相同
        if (s.length() != t.length() || s.length() == 1) {
            return false;
        }
        return checkInclusion(s, t);
    }
    
}
```

---

> ***last change: 2023/4/5***

---
