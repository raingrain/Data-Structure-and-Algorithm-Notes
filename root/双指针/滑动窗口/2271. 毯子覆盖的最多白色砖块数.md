# [2271. 毯子覆盖的最多白色砖块数](https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/)

> - ***Question 1***
>   - 给你一个有序一维整数数组 `tiles` ，其中 `tiles[i]` 表示当前位置上有瓷砖；
>   - 同时给你一个整数 `carpetLen` ，表示可以放在任何位置的一块毯子的长度；
>   - 请你返回使用这块毯子最多可以盖住的瓷砖数。
> - ***Question 2***
>   - 如果上题中给你一个二维整数数组 `tiles` ，其中 `tiles[i] = [li, ri]` ，表示所有在 `li <= j <= ri` 之间的每个位置 `j` 都上都有瓷砖，请你返回使用这块毯子最多可以盖住的瓷砖数；

---

### *Java*

>

```java
class Solution {
    
    // 传递二维数组
    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {
        Arrays.sort(tiles, (a, b) -> a[0] - b[0]);
        int carpetLeft = 0;
        int carpetRight = tiles[carpetLeft][0] + carpetLen - 1;
        int tileCoverByCarpet = 0;
        int p = 0;
        int ans = 0;
        while (p < tiles.length) {
            int curTileLen = tiles[p][1] - tiles[p][0] + 1;
            if (curTileLen >= carpetLen) {
                return carpetLen;
            } else {
                if (tiles[p][1] <= carpetRight) {
                    tileCoverByCarpet += curTileLen;
                    p++;
                } else {
                    ans = tiles[p][0] > carpetRight ? Math.max(ans, tileCoverByCarpet) : Math.max(ans, tileCoverByCarpet + carpetRight - tiles[p][0] + 1);
                    tileCoverByCarpet -= tiles[carpetLeft][1] - tiles[carpetLeft][0] + 1;
                    carpetRight = tiles[++carpetLeft][0] + carpetLen - 1;
                }
            }
        }
        return Math.max(ans, tileCoverByCarpet);
    }
    
    // 传递一维数组
    public int maximumWhiteTiles(int[] tiles, int carpetLen) {
        int left = 0;
        int right = 0;
        int ans = 0;
        while (left < tiles.length) {
            // 当遇到在地毯右边的瓷砖时停止
            while (right < tiles.length && tiles[right] - tiles[left] <= carpetLen) {
                right++;
            }
            ans = Math.max(ans, right - (left++));
        }
        return ans;
    }
    
}
```
