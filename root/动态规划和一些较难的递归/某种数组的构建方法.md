# 某种数组的构建方法

## 左老师课堂讲述

> - ***Question***
>   - 整型数组 `arr` 长度为 `n (3 <= n <= 10^4)` ，最初每个数字是小于等于 `200` 的正数且满足如下条件：
>     - `0` 位置的要求 `arr[0] <= arr[1]` 。
>     - `n - 1` 位置的要求 `arr[n-1] <= arr[n - 2]` 。
>     - 中间 `i` 位置的要求 `arr[i] <= max(arr[i - 1], arr[i + 1])` 。
>   - 但是在 `arr` 有些数字丢失了，比如 `k` 位置的数字之前是正数，丢失之后 `k` 位置的数字为 `0` 。
>   - 请你根据上述条件，计算可能有多少种不同的 `arr` 可以满足以上条件。比如 `[6, 0, 9]` 只有还原成 `[6, 9, 9]` 满足全部三个条件，所以返回 `1` 种，即 `[6, 9, 9]` 达标。

---

## *Java*

> - ***暴力递归***

```java
class Solution {
    
    public int ways(int[] arr) {
        // 假定arr.length位置的数字无穷小
        if (arr[arr.length - 1] != 0) {
            // 最后一个数确定，那么最后一个数只能选择它本身
            return recursion(arr, arr.length - 1, arr[arr.length - 1], 2);
        } else {
            // 最后一个数字不确定，那么最后一个数字可以任意选，它的合法性交给index-1位置的数字确定
            int ans = 0;
            for (int num = 1; num < 201; ++num) {
                ans += recursion(arr, arr.length - 1, num, 2);
            }
            return ans;
        }
    }
    
    // 如果index位置的数字变成了num
    // 并且arr[index]和arr[index+1]的关系为s
    // s==0，代表arr[index] < arr[index+1] 右大
    // s==1，代表arr[index] == arr[index+1] 右=当前
    // s==2，代表arr[index] > arr[index+1] 右小
    // 返回0...index范围上有多少种有效的转化方式？此时index已经确定，违规和终止都判断，如果还能填左边的，这一轮来做index-1位置的决定，但决定的成功与否要看下一轮的返回结果
    public int recursion(int[] arr, int index, int num, int s) {
        if (index == 0) {
            // 只剩下一个数字
            // 由题意1位置的数字必须大于等于0位置的
            // 在这种条件下，要么0位置是需要填的
            //要么它不需要填，但上游的决定必须是它原来的数字
            // 满足这些条件返回1，否则违规
            return ((s == 0 || s == 1) && (arr[0] == 0 || arr[0] == num)) ? 1 : 0;
        }
        // index>0，但index位置有数字，那么上游的决定必须和这个数字相同才不违规
        if (arr[index] != 0 && arr[index] != num) {
            return 0;
        }
        // index>0 ，并且index位置的数真的可以变成num
        int ans = 0;
        if (s == 0 || s == 1) {
            // index+1位置的数大于等于num，那么index-1位置的数字我先假定从0~200自由选择，违规下一层再返回0
            for (int i = 1; i < 201; ++i) {
                ans += recursion(arr, index - 1, i, i < num ? 0 : (i == num ? 1 : 2));
            }
        } else {
            // // index+1位置的数小于num，由题意index+1位置的数字必须大于等于num，继续尝试所有可能
            for (int i = num; i < 201; ++i) {
                ans += recursion(arr, index - 1, i, i == num ? 1 : 2);
            }
        }
        return ans;
    }
    
}
```

---

> ***last change: 2023/2/6***

---
