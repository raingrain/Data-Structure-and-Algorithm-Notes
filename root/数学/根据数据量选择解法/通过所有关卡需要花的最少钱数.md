# 通过所有关卡需要花的最少钱数

## 来源未知

> - ***Question***
>   - 给定数组 `d` ， `d[i]` 表示关卡i中对应的 `i` 号怪兽的能力。
>   - 给定数组 `p` ， `p[i]` 表示买下第 `i` 号怪兽要花的钱。
>   - 最开始你没有能力，你每来到一个关卡，你可以选择花钱买下这个关卡的怪兽，这样怪兽的能力就会加到你的能力上，如果你当前的能力大于当前关卡怪兽的能力，你也可以不买怪兽，怪兽会直接逃跑而你能直接去下一关，你的能力和消耗钱数都不会增加。
>   - 给定关卡数，请你返回通过所有关卡所花的最少钱数。

---

## *Java*

> - ***暴力递归1***
>   - 如果能力值很大，那么这种方法的动态规划表中需要的列就很多，造成空间和时间损耗，本方法适合能力小的范围。

```java
class Solution {
    
    // 目前你的能力是power，你来到了index号怪兽的面前，请返回如果要通过后续所有的怪兽需要花的最少钱数
    public static int recursion1(int[] d, int[] p, int index, int power) {
        if (index == d.length) {
            return 0;
        }
        if (power < p[index]) {
            // 我没有能力，只能买这只怪兽
            return p[index] + recursion1(d, p, index + 1, power + d[index]);
        } else {
            // 我有能力，我可以买或者不买
            int p1 = p[index] + recursion1(d, p, index + 1, power + d[index]);
            int p2 = recursion1(d, p, index + 1, power);
            // 返回最少钱数即可
            return Math.min(p1, p2);
        }
    }
    
}
```

> - ***暴力递归2***
>   - 如果买一个怪兽花的钱很多，那么这种方法的动态规划表中需要的列就很多，造成空间和时间损耗，本方法适合钱少的范围。

```java
class Solution {
    
    // 从0....index号怪兽，花的钱，必须严格等于money
    // 如果通过不了，返回-1
    // 如果可以通过，返回能通过情况下的最大能力值
    public static long recursion2(int[] d, int[] p, int index, int money) {
        if (index == -1) {
            return money == 0 ? 0 : -1;
        }
        long maxPower1 = recursion2(d, p, index - 1, money);
        long p1 = maxPower1 != -1 && maxPower1 >= d[index] ? maxPower1 : -1;
        
        long maxPower2 = recursion2(d, p, index - 1, money - p[index]);
        long p2 = maxPower2 != -1 ? d[index] + maxPower2 : -1;
        
        return Math.max(p1, p2);
    }
    
    // dp表中最后一排从左往右遍历第一个值不是-1的列对应的位置的值就是最少钱数
    public static int test2(int[] d, int[] p) {
        int allMoney = 0;
        for (int num : p) {
            allMoney += num;
        }
        for (int money = 0; money < allMoney; ++money) {
            if (recursion2(d, p, d.length - 1, money) != -1) {
                return money;
            }
        }
        // 都不行那就要花所有的钱
        return allMoney;
    }
    
}
```

---

> ***last change: 2023/1/31***

---
