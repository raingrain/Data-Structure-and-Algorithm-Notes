# 最佳的碰头地点

## [296. 最佳的碰头地点](https://leetcode.cn/problems/best-meeting-point/)

> - ***Question***
>   - 给定一个由 `0` 和 `1` 组成的矩阵。
>   - `0` 代表空地。
>   - `1` 代表人。
>   - 区域内的人可以选择去一个空地上碰头，也可以选择去一个人处聚集。请你找到一个位置，使得所有人到这个位置的距离和最小。

---

## *Java*

> - ***数学推导***
>   - 大流程为找出所有人去某一行距离和最小的最佳行，再找出同理的最佳列，行列交汇位置就是最佳位置。

```java
class Solution {
    
    // 9 22 15 3 10 13
    // 上面为每一行1的个数
    // 准备两个指针分别指向开头结尾，我们看9和13，我们抛出结论，小的数字不可能是最佳行
    // 指向小的指针移动，并且带上之前指向的人，即 31 15 3 10 13，然后就是 31 15 3 23
    // 以此类推即可找到最佳行，最佳列同理

    public int minTotalDistance(int[][] grid) {
        int N = grid.length;
        int M = grid[0].length;
        // 统计行和列上有几个1
        int[] iOnes = new int[N];
        int[] jOnes = new int[M];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (grid[i][j] == 1) {
                    iOnes[i]++;
                    jOnes[j]++;
                }
            }
        }
        int total = 0;
        // 最佳行
        int i = 0;
        int j = N - 1;
        int iRest = 0;
        int jRest = 0;
        while (i < j) {
            if (iOnes[i] + iRest <= iOnes[j] + jRest) {
                total += iOnes[i] + iRest;
                iRest += iOnes[i++];
            } else {
                total += iOnes[j] + jRest;
                jRest += iOnes[j--];
            }
        }
        // 最佳列
        i = 0;
        j = M - 1;
        iRest = 0;
        jRest = 0;
        while (i < j) {
            if (jOnes[i] + iRest <= jOnes[j] + jRest) {
                total += jOnes[i] + iRest;
                iRest += jOnes[i++];
            } else {
                total += jOnes[j] + jRest;
                jRest += jOnes[j--];
            }
        }
        return total;
    }
    
}

```

---

> ***last change: 2023/4/24***

---
