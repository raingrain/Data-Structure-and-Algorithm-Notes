# 编辑距离

## [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

> - ***Question***
>   - 给你两个单词 `word1` 和 `word2` ，请返回将 `word1` 转换成 `word2` 所使用的最少操作数。
>   - 你可以对一个单词进行如下三种操作：
>     - 插入一个字符。
>     - 删除一个字符。
>     - 替换一个字符。
>   - ***tips:***
>     - `0 <= word1.length, word2.length <= 500`
>     - `word1` 和 `word2` 由小写英文字母组成

---

## *Java*

> - ***动态规划***
>   - 样本对应模型。

```java
class Solution {
    
    public int minDistance(String word1, String word2) {
        // 本题中增加，删除，替换的编辑代价都是1
        return editDistance(word1, word2, 1, 1, 1);
    }
    
    // 一般来说，保留的编辑代价认为是0
    // 下面代码中认为增删替的代价均可以指定
    private int editDistance(String s1, String s2, int insert, int delete, int replace) {
        char[] str1 = s1.toCharArray();
        char[] str2 = s2.toCharArray();
        // dp[i][j]表示str1前i个字符编辑成str2前j个字符所需要的最少编辑代价
        int[][] dp = new int[str1.length + 1][str2.length + 1];
        // dp[0][0]
        // str1变成str2的前0个字符（空串），直接逐个字符删除就行
        for (int i = 1; i < dp.length; i++) {
            dp[i][0] = delete * i;
        }
        // str1的空串变成str2字符，str2有几个字符就逐个插入即可
        for (int j = 1; j < dp[0].length; j++) {
            dp[0][j] = insert * j;
        }
        for (int i = 1; i < dp.length; i++) {
            for (int j = 1; j < dp[0].length; j++) {
                // 对于一个普遍位置
                if (str1[i - 1] == str2[j - 1]) {
                    // 如果两者的最后一个字符相等，我看看我的前面怎么变成你的前面
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 如果两者的最后一个字符不相等，我看看我的前面怎么变成你的前面，然后我的最后一个再替换成你的最后一个
                    dp[i][j] = dp[i - 1][j - 1] + replace;
                }
                // 我先让我的前i-1个字符变成你，我再把我多出的最后一个删除
                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + delete);
                // 我先让我的前i个字符变成你的前j-1个字符，我再加上你的最后一个字符
                dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + insert);
            }
        }
        return dp[str1.length][str2.length];
    }
    
}
```

---

> ***last change: 2023/3/11***

---
