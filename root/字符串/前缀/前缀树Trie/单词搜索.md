# 单词搜索

## [79. 单词搜索](https://leetcode.cn/problems/word-search/)

## [剑指 Offer 12. 矩阵中的路径](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)

> - ***Question 1***
>   - 给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则返回 `false` 。
>   - 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
>   - ***tips:***
>     - `m == board.length`
>     - `n = board[i].length`
>     - `1 <= m, n <= 6`
>     - `1 <= word.length <= 15`
>     - `board` 和 `word` 仅由大小写英文字母组成

## [212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/)

> - ***Question 2***
>   - 给定一个 `m x n` 二维字符网格 `board` 和一个单词（字符串）列表 `words` ，返回所有二维网格上的单词。
>   - 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中相邻单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。
>   - ***tips:***
>     - `m == board.length`
>     - `n == board[i].length`
>     - `1 <= m, n <= 12`
>     - `board[i][j]` 是一个小写英文字母
>     - `1 <= words.length <= 3 * 10^4`
>     - `1 <= words[i].length <= 10`
>     - `words[i]` 由小写英文字母组成
>     - `words` 中的所有字符串互不相同

---

## *Java*

> - ***前缀树 + 深度优先搜索***
>   - 核心思想是对矩阵中的每一个点进行深度优先搜索来查询有没有单词表中的单词，并在搜索的过程中使用前缀树进行剪枝。

```java
class Solution {
    
    // Question 1
    public boolean exist(char[][] board, String word) {
        return findWords(board, new String[]{word}).size() != 0;
    }
    
    // Question 2
    public List<String> findWords(char[][] board, String[] words) {
        // 前缀树头节点
        TrieNode head = new TrieNode();
        // 去重
        HashSet<String> set = new HashSet<>();
        for (String word : words) {
            if (!set.contains(word)) {
                addWordToTrie(head, word);
                set.add(word);
            }
        }
        // 答案
        List<String> ans = new ArrayList<>();
        // 沿途走过的字符，收集起来，存在path里
        LinkedList<Character> path = new LinkedList<>();
        for (int row = 0; row < board.length; row++) {
            for (int col = 0; col < board[0].length; col++) {
                // 枚举在board中的所有位置
                // 每一个位置出发的情况下，答案都收集
                recursion(board, row, col, path, head, ans);
            }
        }
        return ans;
    }
    
    // 从board[row][col]位置的字符出发，
    // 之前的路径上，走过的字符，记录在path里
    // cur还没有登上，有待检查能不能登上去的前缀树的节点
    // 如果找到words中的某个str，就记录在ans里
    // 返回值，从row,col出发，一共找到了多少个str
    private int recursion(char[][] board, int row, int col, LinkedList<Character> path, TrieNode cur, List<String> ans) {
        char c = board[row][col];
        if (c == 0) {
            // 这个row col位置是之前走过的位置
            return 0;
        }
        // 如果没路，或者这条路上最终的字符串之前加入过结果里，直接剪枝返回
        if (cur.nexts[c] == null || cur.nexts[c].pass == 0) {
            return 0;
        }
        // 没有走回头路且能登上去，前缀树来到对应路径之后的节点
        cur = cur.nexts[c];
        // 当前位置的字符加到路径里去
        path.addLast(c);
        // 从row和col位置出发，后续一共搞定了多少答案
        int res = 0;
        // 当我来到row col位置，如果决定不往后走了。是不是已经搞定了某个字符串了
        if (cur.end) {
            ans.add(generatePathString(path));
            cur.end = false;
            res++;
        }
        // 往上、下、左、右，四个方向尝试
        // 标记为走过
        board[row][col] = 0;
        // 上游判断越界
        if (row > 0) {
            res += recursion(board, row - 1, col, path, cur, ans);
        }
        if (row < board.length - 1) {
            res += recursion(board, row + 1, col, path, cur, ans);
        }
        if (col > 0) {
            res += recursion(board, row, col - 1, path, cur, ans);
        }
        if (col < board[0].length - 1) {
            res += recursion(board, row, col + 1, path, cur, ans);
        }
        // 恢复现场
        board[row][col] = c;
        path.pollLast();
        // 减去有几个单词检查过了
        cur.pass -= res;
        return res;
    }
    
    // 将给定的字符串路径链表生成字符串
    private String generatePathString(LinkedList<Character> path) {
        char[] word = new char[path.size()];
        int index = 0;
        for (Character c : path) {
            word[index++] = c;
        }
        return String.valueOf(word);
    }
    
    // 前缀树节点
    private static class TrieNode {
        
        public TrieNode[] nexts;
        public int pass;
        public boolean end;
        
        public TrieNode() {
            nexts = new TrieNode[256];
            pass = 0;
            end = false;
        }
        
    }
    
    // 给定前缀树的头节点，将一个单词加到前缀树上
    private void addWordToTrie(TrieNode head, String word) {
        head.pass++;
        char[] str = word.toCharArray();
        TrieNode node = head;
        for (char c : str) {
            if (node.nexts[c] == null) {
                node.nexts[c] = new TrieNode();
            }
            node = node.nexts[c];
            node.pass++;
        }
        node.end = true;
    }
    
}
```

---

> ***last change: 2023/4/13***

---
