# 编辑距离

## [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

> - ***Question 1***
>   - 给你两个单词 `word1` 和 `word2` ，请返回将 `word1` 转换成 `word2` 所使用的最少操作数。
>   - 你可以对一个单词进行如下三种操作：
>     - 插入一个字符。
>     - 删除一个字符。
>     - 替换一个字符。
>   - ***tips:***
>     - `0 <= word1.length, word2.length <= 500`
>     - `word1` 和 `word2` 由小写英文字母组成

## 字节跳动面试

> - ***Question 2***
>   - 给定两个字符串 `s1` 和 `s2` ，问 `s2` 最少删除几个字符可以成为 `s1` 的子串。

---

## *Java*

> - ***Question 1: 动态规划***
>   - 样本对应模型。

```java
class Solution {
    
    public int minDistance(String word1, String word2) {
        // 本题中增加，删除，替换的编辑代价都是1
        return editDistance(word1, word2, 1, 1, 1);
    }
    
    // 一般来说，保留的编辑代价认为是0
    // 下面代码中认为增删替的代价均可以指定
    private int editDistance(String s1, String s2, int insert, int delete, int replace) {
        char[] str1 = s1.toCharArray();
        char[] str2 = s2.toCharArray();
        // dp[i][j]表示str1前i个字符编辑成str2前j个字符所需要的最少编辑代价
        int[][] dp = new int[str1.length + 1][str2.length + 1];
        // dp[0][0]
        // str1变成str2的前0个字符（空串），直接逐个字符删除就行
        for (int i = 1; i < dp.length; i++) {
            dp[i][0] = delete * i;
        }
        // str1的空串变成str2字符，str2有几个字符就逐个插入即可
        for (int j = 1; j < dp[0].length; j++) {
            dp[0][j] = insert * j;
        }
        for (int i = 1; i < dp.length; i++) {
            for (int j = 1; j < dp[0].length; j++) {
                // 对于一个普遍位置
                if (str1[i - 1] == str2[j - 1]) {
                    // 如果两者的最后一个字符相等，我看看我的前面怎么变成你的前面
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 如果两者的最后一个字符不相等，我看看我的前面怎么变成你的前面，然后我的最后一个再替换成你的最后一个
                    dp[i][j] = dp[i - 1][j - 1] + replace;
                }
                // 我先让我的前i-1个字符变成你，我再把我多出的最后一个删除
                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + delete);
                // 我先让我的前i个字符变成你的前j-1个字符，我再加上你的最后一个字符
                dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + insert);
            }
        }
        return dp[str1.length][str2.length];
    }
    
}
```

> - ***Question 2: 生成子串序列后遍历子串序列查找子串在不在另一个字符串中***

```java
class Solution {
    
    // 求出s2所有的子序列，然后按照长度排序，长度大的排在前面。
    // 然后考察哪个子序列字符串和s1的某个子串相等(KMP)，答案就出来了。
    // 因为题目原本的样本数据中，有特别说明s2的长度很小。所以这么做也没有太大问题，也几乎不会超时。
    // 但是如果给定的s2长度远大于s1，这么做就不合适了。因为这时候生成子序列的代价很高
    public int minCost(String s1, String s2) {
        List<String> s2SubStrings = new ArrayList<>();
        recursion(s2.toCharArray(), 0, "", s2SubStrings);
        s2SubStrings.sort((o1, o2) -> o2.length() - o1.length());
        for (String subString : s2SubStrings) {
            // 每一个子串玩一次KMP，总代价为O(2 ^ str2.length * str1.length)
            if (s1.contains(subString)) {
                return s2.length() - subString.length();
            }
        }
        return s2.length();
    }
    
    // 通过递归求出一个字符串的所有子串，时间复杂度为O(2 ^ str.length)
    private void recursion(char[] str, int index, String path, List<String> list) {
        if (index == str.length) {
            list.add(path);
            return;
        }
        recursion(str, index + 1, path, list);
        recursion(str, index + 1, path + str[index], list);
    }
    
}
```

> - ***Question 2: 动态规划***
>   - 我们只需要遍历 `s1` 的所有按照开头来分类的子串，将 `s2` 和它过一遍下面的 `onlyDelete` 方法，即每一个子串都做一遍动态规划，最后返回最小编辑距离即可。

```java
class Solution {
    
    // str1只通过删除字符的方式变成str2，返回所需的最小删除次数
    private int onlyDelete(char[] str1, char[] str2) {
        // 被删的长度肯定要大于目标长度，下面同理
        if (str1.length < str2.length) {
            return Integer.MAX_VALUE;
        }
        // dp[i][j]表示str1前i个字符编辑成str2前j个字符所需要的最少编辑代价（只能删除）
        int[][] dp = new int[str1.length + 1][str2.length + 1];
        // 先认为都不能
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        // 一个字符串变成空删除字符长度次
        for (int i = 0; i < dp.length; i++) {
            dp[i][0] = i;
        }
        for (int i = 1; i < dp.length; i++) {
            for (int j = 1; j <= Math.min(dp[0].length, i); j++) {
                // 我最后一个字符不等于你，我看看前面的字符能不能变成你
                // 我最后一个字符等于你，我也可以看看前面的字符能不能变成你
                if (dp[i - 1][j] != Integer.MAX_VALUE) {
                    dp[i][j] = dp[i - 1][j] + 1;
                }
                // 我最后一个字符等于你，我看看前面的字符能不能变成你前面的字符
                if (str1[i - 1] == str2[j - 1] && dp[i - 1][j - 1] != Integer.MAX_VALUE) {
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
                }
            }
        }
        return dp[dp.length - 1][dp[0].length - 1];
    }
    
}
```

---

> ***last change: 2023/3/25***

---
