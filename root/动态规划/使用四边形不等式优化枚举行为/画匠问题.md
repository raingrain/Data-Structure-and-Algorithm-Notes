# 画匠问题

## [410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/)

> - ***Question***
>   - 原题目：给定一个非负整数数组 `nums` 和一个整数 `k` ，你需要将这个数组分成 `k` 个非空的连续子数组。设计一个算法使得这 `k` 个子数组各自和的最大值最小。
>   - 更容易理解的题目：给定一个非负整数数组 `nums` ，表示完成一幅画作需要的时间，再给定一个整数 `k` ，表示画匠的数量，每个画匠只能画连在一起的画作。所有的画家并行工作，请返回完成所有的画作需要的最少时间。题解均以这个题面进行描述。
>   - `nums = [3, 1, 4], k = 2` 。最好的分配方式为第一个画匠画 `3` 和 `1` ，所需时间为 `4` 。第二个画匠画 `4` ，所需时间为 `4` 。因为并行工作，所以最少时间为 `4` 。如果分配方式为第一个画匠画 `3` ，所需时间为 `3` 。第二个画匠画 `1` 和 `4` ，所需的时间为 `5` 。那么最少时间为 `5` ，显然没有第一种分配方式好。所以返回 `4` 。
>   - `nums = [1, 1, 1, 4, 3], num = 3` 。最好的分配方式为第一个画匠画前三个 `1` ，所需时间为 `3` 。第二个画匠画 `4` ，所需时间为 `4` 。第三个画匠画 `3` ，所需时间为 `3` 。返回 `4` 。
>   - ***tips:***
>     - `1 <= nums.length <= 1000`
>     - `0 <= nums[i] <= 10^6`
>     - `1 <= m <= min(50, nums.length)`

---

## *Java*

> - ***动态规划***
>   - 定义一张dp表。 `dp[i][j]` 的含义为在 `nums[0 ~ i]` 上的画，由 `j` 个画家画所需要的最少时间。我们以最后一个画家负责的范围来讨论普遍位置的依赖，看注释。
>   - 时间复杂度为 `O(N ^ 2 * k)` ， `N` 为画作数量。

```java
class Solution {
    
    public int splitArray(int[] nums, int k) {
        return dp(nums, k);
    }
    
    public int dp(int[] nums, int k) {
        // 先准备一张可以规避讨论的前缀和数组用于求区间和
        int[] preSum = new int[nums.length + 1];
        for (int i = 0; i < nums.length; ++i) {
            preSum[i + 1] = preSum[i] + nums[i];
        }
        // 我们实际要求的是从第一列开始的
        int[][] dp = new int[nums.length][k + 1];
        for (int j = 1; j < k + 1; ++j) {
            // 我们只有一幅画，但有很多个画家
            // 不管画家的数量有多少，画完一副画的时间是确定的
            dp[0][j] = nums[0];
        }
        for (int i = 1; i < nums.length; ++i) {
            // 对于不同的画的数量，我们只有一个画家进行绘制的时候
            // 绘制所用的时间就是指定范围内的所有画作所需的时间和
            dp[i][1] = preSum[i + 1] - preSum[0];
        }
        // 假定一张4*4的dp表，4副画3个画家，我们分析一下dp[3][3]的依赖
        // 最后一个画家不负责绘制（开摆），其他两个画家画三副画，依赖dp[3][2]
        // 最后一个画家负责最后一张画，剩余的画由其他画家画，依赖dp[2][2]与最后一名画家绘制所需时间的最大值
        // 最后一个画家负责最后两张画，其他两个画家画二幅画，依赖dp[1][2]与最后一名画家绘制所需时间的最大值
        // 最后一个画家负责最后三张画，其他两个画家画一幅画，依赖dp[0][2]与最后一名画家绘制所需时间的最大值
        // 最后一个画家画全部，依赖所绘制范围的累加和
        // 我们发现一个普遍位置依赖它左侧紧贴位置及其往上的所有格子，我们可以大方向从上往下，每一行从左往右
        for (int i = 1; i < nums.length; ++i) {
            for (int j = 2; j < k + 1; ++j) {
                int ans = Integer.MAX_VALUE;
                // leftEnd表示0 ~ leftEnd区域由前j - 1个画家画，leftEnd + 1 ~ i 由最后一个画家画
                for (int leftEnd = -1; leftEnd <= i; ++leftEnd) {
                    // leftEnd == -1表示最后一个画家画全部，那么前j - 1个画家不画，否则有依赖
                    int leftCost = leftEnd == -1 ? 0 : dp[leftEnd][j - 1];
                    // leftEnd == i表示最后一个画家不画，那么前j - 1个画家画全部，否则依赖为区间累加和（因为是一个人画）
                    int rightCost = leftEnd == i ? 0 : preSum[i + 1] - preSum[leftEnd + 1];
                    // 绘制当前区域所需时间为并行的最大值
                    int curCost = Math.max(leftCost, rightCost);
                    if (curCost < ans) {
                        // 有更短的时间内能画完就更新一下最终结果
                        ans = curCost;
                    }
                }
                dp[i][j] = ans;
            }
        }
        // k个画家画0~nums.length - 1上的画所需的最短时间
        return dp[nums.length - 1][k];
    }
    
}
```

> - ***动态规划 + 四边形不等式优化枚举行为***
>   - 这是一个有枚举行为的二维动态规划。当两个可变参数固定一个，另外一个参数与答案之间存在单调性，且两个参数的单调性相反。画家的数量与所需时间呈负相关。画作数量与所需时间呈正相关。符合四边形不等式使用条件。
>   - 为了使用左下限和下上限，我们大方向从左往右，每一列自底向上，对于最后一行的格子我们只找到左格子，只有下限，上限定为画作数量即可。我们枚举的 `leftEnd` 范围被缩小了。
>   - 四边形不等式让时间复杂度降低一阶，变为 `O(N * k)` 。

```java
class Solution {
    
    public int splitArray(int[] nums, int k) {
        return dp(nums, k);
    }
    
    public int dp(int[] nums, int k) {
        int[] preSum = new int[nums.length + 1];
        for (int i = 0; i < nums.length; ++i) {
            preSum[i + 1] = preSum[i] + nums[i];
        }
        int[][] dp = new int[nums.length][k + 1];
        // 用于记录对应dp位置求出最小耗费时间时的leftEnd
        int[][] best = new int[nums.length][k + 1];
        for (int j = 1; j < k + 1; ++j) {
            dp[0][j] = nums[0];
            // 前j-1个画家负责空
            best[0][j] = -1;
        }
        for (int i = 1; i < nums.length; ++i) {
            dp[i][1] = preSum[i + 1] - preSum[0];
            // 前j-1个画家负责空
            best[i][1] = -1;
        }
        for (int j = 2; j < k + 1; ++j) {
            for (int i = nums.length - 1; i >= 1; --i) {
                int ans = Integer.MAX_VALUE;
                // 下限
                int down = best[i][j - 1];
                // 上限，最后一行就自定义，不然就直接拿值
                int up = i == nums.length - 1 ? nums.length - 1 : best[i + 1][j];
                // 做出的选择
                int bestChoose = -1;
                for (int leftEnd = down; leftEnd <= up; ++leftEnd) {
                    int leftCost = leftEnd == -1 ? 0 : dp[leftEnd][j - 1];
                    int rightCost = leftEnd == i ? 0 : preSum[i + 1] - preSum[leftEnd + 1];
                    int curCost = Math.max(leftCost, rightCost);
                    // 注意，小于等于每一个题都不同，直接用对数器验证
                    if (curCost < ans) {
                        // 两个都更新
                        ans = curCost;
                        bestChoose = leftEnd;
                    }
                }
                // 填此时的leftEnd
                best[i][j] = bestChoose;
                dp[i][j] = ans;
            }
        }
        return dp[nums.length - 1][k];
    }
    
}
```

> - ***二分反解***
>   - `nums` 数组中的值依然表示完成一幅画作需要的时间，但是规定每个画匠画画的时间不能多于 `limit` ，那么要几个画匠才够呢？这个问题的实现非常简单，从左到右遍历 `nums` 的过程中做累加，一旦累加超过 `limit` ，则认为当前的画 `nums[i]` 必须分给下一个画匠，那么就让累加和清零，并从 `nums[i]` 开始重新累加。遍历的过程中如果发现有某一幅画的时间大于 `limit` ，说明即使是单独分配一个画匠只画这一幅画，也不能满足每个画匠所需时间小于或等于 `limit` 这个要求。遇到这种情况就直接返回系统最大值，表示无论分多少个画匠， `limit` 都满足不了。该方法的实现查看 `getNeed` 函数。
>   - 利用二分法，通过调整 `limit` 的大小，看看需要的画匠数目是大于画匠总数还是少于画匠总数，然后决定是将答案往上调整还是往下调整，那么 `limit` 的范围一开始为 `[0 ~ nums所有值的累加和]` ，然后不断二分，即可缩小范围，最终确定 `limit` 到底是多少。
>   - `getNeed` 方法的时间复杂度为 `O(N)` ，二分为 `O(logN)` ，总时间复杂度为 `O(N * logN)` 。

```java
class Solution {
    
    public int splitArray(int[] nums, int k) {
        return divide(nums, k);
    }
    
    public int divide(int[] nums, int k) {
        // 求总和，答案一定比它小
        long sum = 0;
        for (int num : nums) {
            sum += num;
        }
        long left = 0;
        long right = sum;
        long ans = 0;
        while (left <= right) {
            long mid = (left + right) / 2;
            // 问最多使用mid时间完成这一堆画，最少需要几个画家
            long cur = getNeed(nums, mid);
            if (cur <= k) {
                // 如果需要的人数的比题目少，说明题目要求的画家一定能在更短的时间内完成这一堆画作，缩短时间
                ans = mid;
                right = mid - 1;
            } else {
                // 如果小的代价需要的人数的比题目多了，说明题目要求的画家一定需要更长的时间来完成这一堆画作
                left = mid + 1;
            }
        }
        return (int) ans;
    }
    
    public int getNeed(int[] nums, long aim) {
        // 先检查有没有违规项
        for (int num : nums) {
            if (num > aim) {
                return Integer.MAX_VALUE;
            }
        }
        int ans = 1;
        int sum = nums[0];
        for (int i = 1; i < nums.length; ++i) {
            if (sum + nums[i] > aim) {
                // 超过了，需要一个新的画家
                ++ans;
                // 区域累加和重置
                sum = nums[i];
            } else {
                // 区域累加和一直加到小于要求的时间代价
                sum += nums[i];
            }
        }
        return ans;
    }
    
}
```

---

> ***last change: 2023/2/1***

---
