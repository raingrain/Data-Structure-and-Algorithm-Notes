# 所有居民到办公室所耗费的最少汽油

## 微软

> - ***Question***
>   - 给定两个数组 `A` 和 `B` ，比如 `A = [0, 1, 1], B = [1, 2, 3]` ， `A[0] = 0, B[0] = 1` 表示 `0` 到 `1` 有双向道路， `A[1] = 1, B[1] = 2` 表示 `1` 到 `2` 有双向道路， `A[2] = 1, B[2] = 3` 表示 `1` 到 `3` 有双向道路。
>   - 给定数字 `N` ，编号从 `0 ~ N` ，所以一共 `N + 1` 个节点。
>   - 题目输入一定保证所有节点都联通，并且一定没有环。
>   - 默认办公室是 `0` 节点，其他 `1 ~ N` 节点上，每个节点上都有一个居民。
>   - 每天所有居民都去往 `0` 节点上班。
>   - 所有的居民都有一辆 `5` 座的车，也都乐意和别人一起坐车。
>   - 车不管负重是多少，只要走过一条路，就耗费 `1` 的汽油。
>   - 比如 `A, B, C` 的居民，开着自己的车来到 `D` 居民的位置，一共耗费 `3` 的汽油。
>   - `D` 居民和 `E` 居民之间，假设有一条路。
>   - 那么 `D` 居民可以接上 `A, B, C` ， `4` 个人可以用一辆车，去往 `E` 的话，就再耗费 `1` 的汽油。
>   - 求所有居民去办公室的路上，最少耗费多少汽油。

---

## *Java*

> - ***DFS***

```java
class Solution {

    // 记录此时的dfn序来到了哪里
    public static int cnt = 0;

    public static int minFuel(int[] a, int[] b, int n) {
        // 先建图
        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<>());
        }
        for (int i = 0; i < a.length; i++) {
            // 无向图，所以边是双向的
            graph.get(a[i]).add(b[i]);
            graph.get(b[i]).add(a[i]);
        }
        // 建图完毕
        // 根据题目描述，办公室一定是0号点
        // 所有员工一定是往0号点汇聚
        int[] dfn = new int[n + 1];
        int[] size = new int[n + 1];
        int[] cost = new int[n + 1];
        cnt = 0;
        dfs(graph, 0, dfn, size, cost);
        // 所有人都来到0号点
        return cost[0];
    }

    // 图graph
    // 当前节点的编号cur
    // 以cur为头的整棵树，每个节点，去分配dfn序号！
    // 以cur为头的整棵树，每个节点，都去求子树的节点个数，size
    // 以cur为头的整棵树，所有节点汇聚到cur，废了多少油，填入到cost
    public static void dfs(
            ArrayList<ArrayList<Integer>> graph,
            int cur,
            int[] dfn,
            int[] size,
            int[] cost) {
        dfn[cur] = ++cnt;
        // 初始时只知道树上只有一个头节点
        size[cur] = 1;
        for (int next : graph.get(cur)) {
            if (dfn[next] == 0) {
                dfs(graph, next, dfn, size, cost);
                size[cur] += size[next];
                // 所有车先要来到next
                cost[cur] += cost[next];
                // 这些车从next来到cur
                // 有size[next]这么多人从next上来，除5向上取整就是所需车数
                cost[cur] += (size[next] + 4) / 5;
            }
        }
    }

    public static void main(String[] args) {
        int[] a1 = {0, 1, 1};
        int[] b1 = {1, 2, 3};
        int n1 = 3;
        System.out.println(minFuel(a1, b1, n1));

        int[] a2 = {1, 1, 1, 9, 9, 9, 9, 7, 8};
        int[] b2 = {2, 0, 3, 1, 6, 5, 4, 0, 0};
        int n2 = 9;
        System.out.println(minFuel(a2, b2, n2));
    }

}
```

---

> ***last change: 2023/5/15***

---
