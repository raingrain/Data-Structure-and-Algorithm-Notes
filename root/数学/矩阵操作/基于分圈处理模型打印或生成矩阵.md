# 基于分圈处理模型打印或生成矩阵

## [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

## [剑指 Offer 29. 顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

> - ***Question 1***
>   - 给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照顺时针螺旋顺序 ，返回矩阵中的所有元素。
>   - ***tips:***
>     - `m == matrix.length`
>     - `n == matrix[i].length`
>     - `1 <= m, n <= 10`
>     - `-100 <= matrix[i][j] <= 100`

## [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

> - ***Question 2***
>   - 给你一个正整数 `n` ，生成一个包含 `1` 到 `n^2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵  `matrix` 。
>   - ***tips:***
>     - `1 <= n <= 20`

## [2326. 螺旋矩阵 IV](https://leetcode.cn/problems/spiral-matrix-iv/)

> - ***Question 3***
>   - 给你两个整数 `m` 和 `n` ，表示矩阵的维数。另给你一个整数链表的头节点 `head` 。
>   - 请你生成一个大小为 `m x n` 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵左上角开始、顺时针按螺旋 顺序填充。如果还存在剩余的空格，则用 `-1` 填充。返回生成的矩阵。
>   - ***tips:***
>     - `1 <= m, n <= 10^5`
>     - `1 <= m * n <= 10^5`
>     - 链表中节点数目在范围 `[1, m * n]` 内
>     - `0 <= Node.val <= 1000`

## 大厂面试题

> - ***Question 4***
>   - 给定数字打印图形。
>   - 例如给定数字 `10` ，生成如下图形：

```java
* * * * * * * * * * 
                  * 
  * * * * * * *   * 
  *           *   * 
  *   * * *   *   * 
  *   *   *   *   * 
  *   *       *   * 
  *   * * * * *   * 
  *               * 
  * * * * * * * * * 
```

## 之字形打印矩阵

> - ***Question 5***
>   - 给定一个矩阵，我们知道它可以从左上到右下被切分成一条条斜向的层，我们像之字一样打印它。
>   - 给定矩阵 `{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}` ，打印如下序列： `1 2 5 9 6 3 4 7 10 11 8 12` 。

---

## *Java*

> - ***分圈打印***
>   - 掌握这一题的代码模型（长方形矩阵更具有代表性），后面的题目都是一样的，时间复杂度为矩阵元素个数，因为只需要遍历整个矩阵一次。

```java
class Solution {
    
    // 输出一个列表
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> list = new ArrayList<>();
        int row1 = 0;
        int col1 = 0;
        int row2 = matrix.length - 1;
        // 注意长方形矩阵的坐标不能省去[0]
        int col2 = matrix[0].length - 1;
        while (row1 <= row2 && col1 <= col2) {
            printRing(matrix, list, row1++, col1++, row2--, col2--);
        }
        return list;
    }
    
    private void printRing(int[][] matrix, List<Integer> list, int row1, int col1, int row2, int col2) {
        // 要考虑长方形中只剩下一条边或者一行作为一圈的情况
        if (row1 == row2) {
            for (int j = col1; j <= col2; ++j) {
                list.add(matrix[row1][j]);
            }
        } else if (col1 == col2) {
            for (int i = row1; i <= row2; ++i) {
                list.add(matrix[i][col1]);
            }
        } else {
            // 从圈的左上角开始顺时针遍历
            // 记录当前行和列
            int curRow = row1;
            int curCol = col1;
            while (curCol != col2) {
                list.add(matrix[row1][curCol++]);
            }
            while (curRow != row2) {
                list.add(matrix[curRow++][col2]);
            }
            while (curCol != col1) {
                list.add(matrix[row2][curCol--]);
            }
            while (curRow != row1) {
                list.add(matrix[curRow--][col1]);
            }
        }
    }
    
}

class Solution {
    
    // 全局答案数组和遍历到的索引
    private int[] list;
    private int index;
    
    // 输出一维数组
    public int[] spiralOrder(int[][] matrix) {
        if (matrix.length == 0) {
            return new int[]{};
        }
        this.list = new int[matrix.length * matrix[0].length];
        this.index = 0;
        int row1 = 0;
        int col1 = 0;
        int row2 = matrix.length - 1;
        int col2 = matrix[0].length - 1;
        while (row1 <= row2 && col1 <= col2) {
            printRing(matrix, row1++, col1++, row2--, col2--);
        }
        return list;
    }
    
    private void printRing(int[][] matrix, int row1, int col1, int row2, int col2) {
        if (row1 == row2) {
            for (int j = col1; j <= col2; ++j) {
                list[index++] = matrix[row1][j];
            }
        } else if (col1 == col2) {
            for (int i = row1; i <= row2; ++i) {
                list[index++] = matrix[i][col1];
            }
        } else {
            int curRow = row1;
            int curCol = col1;
            while (curCol != col2) {
                list[index++] = matrix[row1][curCol++];
            }
            while (curRow != row2) {
                list[index++] = matrix[curRow++][col2];
            }
            while (curCol != col1) {
                list[index++] = matrix[row2][curCol--];
            }
            while (curRow != row1) {
                list[index++] = matrix[curRow--][col1];
            }
        }
    }
    
}
```

> - ***分圈生成正方形矩阵***

```java
class Solution {
    
    // 当前要填入的数字
    private int number;
    
    public int[][] generateMatrix(int n) {
        this.number = 1;
        int[][] matrix = new int[n][n];
        int row1 = 0;
        int col1 = 0;
        int row2 = matrix.length - 1;
        int col2 = matrix.length - 1;
        while (row1 <= row2) {
            generateRing(matrix, row1++, col1++, row2--, col2--);
        }
        return matrix;
    }
    
    private void generateRing(int[][] matrix, int row1, int col1, int row2, int col2) {
        // 正方形矩阵的特殊之处，中心点有的话只有一个
        if (row1 == row2) {
            matrix[row1][col1] = number++;
        }
        int curRow = row1;
        int curCol = col1;
        while (curCol != col2) {
            matrix[row1][curCol++] = number++;
        }
        while (curRow != row2) {
            matrix[curRow++][col2] = number++;
        }
        while (curCol != col1) {
            matrix[row2][curCol--] = number++;
        }
        while (curRow != row1) {
            matrix[curRow--][col1] = number++;
        }
    }
    
}
```

> - ***分圈按链表生成矩阵***

```java
class Solution {
    
    // 全局链表遍历节点和结果矩阵
    private ListNode head;
    private int[][] matrix;
    
    public int[][] spiralMatrix(int m, int n, ListNode head) {
        this.head = head;
        this.matrix = new int[m][n];
        int row1 = 0;
        int col1 = 0;
        int row2 = matrix.length - 1;
        int col2 = matrix[0].length - 1;
        while (row1 <= row2 && col1 <= col2) {
            generateRing(row1++, col1++, row2--, col2--);
        }
        return matrix;
    }
    
    // 参考Question 1
    private void generateRing(int row1, int col1, int row2, int col2) {
        if (row1 == row2) {
            for (int j = col1; j <= col2; ++j) {
                addNum(row1, j);
            }
        } else if (col1 == col2) {
            for (int i = row1; i <= row2; ++i) {
                addNum(i, col1);
            }
        } else {
            int curRow = row1;
            int curCol = col1;
            while (curCol != col2) {
                addNum(row1, curCol++);
            }
            while (curRow != row2) {
                addNum(curRow++, col2);
            }
            while (curCol != col1) {
                addNum(row2, curCol--);
            }
            while (curRow != row1) {
                addNum(curRow--, col1);
            }
        }
    }
    
    // 判断生成-1还是链表元素并将链表后移
    private void addNum(int i, int j) {
        if (head != null) {
            matrix[i][j] = head.val;
            head = head.next;
        } else {
            matrix[i][j] = -1;
        }
    }
    
}
```

> - ***将两个圈视为一个圈进行打印***
>   - 这个不完整的回字形打印看起来很难，其实先把矩阵填好，再打印矩阵即可。按圈生成矩阵，注意是两层视为一个圈，上右下都是外圈打印，而左是内圈打印。每一条路径都与其他路径之间隔一层。

```java
class Solution {
    
    // 思路是先生成矩阵再打印而不是嗯打印
    public static void printStar(int N) {
        int topLeft = 0;
        int bottomRight = N - 1;
        char[][] matrix = new char[N][N];
        // 先初始矩阵
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                matrix[i][j] = ' ';
            }
        }
        // 生成星号标记
        while (topLeft <= bottomRight) {
            generateRing(matrix, topLeft, bottomRight);
            topLeft += 2;
            bottomRight -= 2;
        }
        // 打印矩阵
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
    }
    
    public static void generateRing(char[][] matrix, int topLeft, int bottomRight) {
        for (int col = topLeft; col <= bottomRight; col++) {
            matrix[topLeft][col] = '*';
        }
        for (int row = topLeft + 1; row <= bottomRight; row++) {
            matrix[row][bottomRight] = '*';
        }
        for (int col = bottomRight - 1; col > topLeft; col--) {
            matrix[bottomRight][col] = '*';
        }
        for (int row = bottomRight - 1; row > topLeft + 1; row--) {
            matrix[row][topLeft + 1] = '*';
        }
    }
    
    public static void main(String[] args) {
        printStar(50);
    }
    
}
```

> - ***之字形打印矩阵***
>   - 准备两个点，两个点之间的连线视为一层，每次打印一层，注意打印方向即可。

```java
class Solution {
    
    public static void printMatrixZigZag(int[][] matrix) {
        // 只能向右走和向下走
        // 走右上
        int row1 = 0;
        int col1 = 0;
        // 只能向下走和向右走
        // 走左下
        int row2 = 0;
        int col2 = 0;
        int endRow = matrix.length - 1;
        int endCol = matrix[0].length - 1;
        boolean fromUp = false;
        while (row1 != endRow + 1) {
            printLine(matrix, row1, col1, row2, col2, fromUp);
            row1 = col1 == endCol ? row1 + 1 : row1;
            col1 = col1 == endCol ? col1 : col1 + 1;
            col2 = row2 == endRow ? col2 + 1 : col2;
            row2 = row2 == endRow ? row2 : row2 + 1;
            fromUp = !fromUp;
        }
        System.out.println();
    }
    
    public static void printLine(int[][] matrix, int row1, int col1, int row2, int col2, boolean fromUp) {
        if (fromUp) {
            while (row1 != row2 + 1) {
                System.out.print(matrix[row1++][col1--] + " ");
            }
        } else {
            while (row2 != row1 - 1) {
                System.out.print(matrix[row2--][col2++] + " ");
            }
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
        printMatrixZigZag(matrix);
        
    }
    
}
```

---

> ***last change: 2022/11/13***

---
