# 安装栅栏

## [587. 安装栅栏](https://leetcode.cn/problems/erect-the-fence/)

> - **Question**
>   - 给定一个数组 `trees` ，其中 `trees[i] = [xi, yi]` 表示树在花园中的位置。
>   - 你被要求用最短长度的绳子把整个花园围起来，因为绳子很贵。只有把所有的树都围起来，花园才围得很好。
>   - 返回恰好位于围栏周边的树木的坐标。
>   - **Tips**
>     - `1 <= points.length <= 3000`
>     - `points[i].length == 2`
>     - `0 <= xi, yi <= 100`
>     - 所有给定的点都是唯一的

## Java

> - **凸包模板之Andrew算法**
>   - `Andrew` 使用单调链算法，该算法与 `Graham` 扫描算法类似。它们主要的不同点在于凸壳上点的顺序。与 `Graham` 扫描算法按照点计较顺序排序不同，我们按照点的 `x` 坐标排序，如果两个点又相同的 `x` 坐标，那么就按照它们的 `y` 坐标排序。显然排序后的最大值与最小值一定在凸包上，而且因为是凸多边形，我们如果从一个点出发逆时针走，轨迹总是「左拐」的，一旦出现右拐，就说明这一段不在凸包上，因此我们可以用一个单调栈来维护上下凸壳。
>   - 仔细观察可以发现，最小值与最大值一定位于凸包的最左边与最右边，从左向右看，我们将凸壳考虑成 `2` 个子边界组成：上凸壳和下凸壳。下凸壳一定是从最小值一直左拐直到最大值，上凸壳一定是从最大值左拐到最小值，因此我们首先升序枚举求出下凸壳，然后降序求出上凸壳。
>   - 我们首先将最初始的两个点添加到凸壳中，然后遍历排好序的 `trees` 数组。对于每个新的点，我们检查当前点是否在最后两个点的逆时针方向上，轨迹是否是左拐。如果是的话，当前点直接被压入凸壳 `hull` 中， `cross` 返回的结果为正数；如果不是的话 `cross` 返回的结果为负数，我们可以知道栈顶的元素在凸壳里面而不是凸壳边上。我们继续从 `hull` 中弹出元素直到当前点相对于栈顶的两个点的逆时针方向上。
>   - 这个方法中，我们不需要显式地考虑共线的点，因为这些点已经按照 `x` 坐标排好了序。所以如果有共线的点，它们已经被隐式地按正确顺序考虑了。通过这样，我们会一直遍历到 `x` 坐标最大的点为止。但是凸壳还没有完全求解出来。目前求解出来的部分只包括凸壳的下半部分。现在我们需要求出凸壳的上半部分。
>   - 我们继续找下一个逆时针的点并将不在边界上的点从栈中弹出，但这次我们遍历的顺序是按照 `x` 坐标从大到小，我们只需要从后往前遍历有序数组 `trees` 即可。我们将新的上凸壳的值添加到之前的 `hull` 数组中。最后 `hull` 数组返回了我们需要的边界上的点。需要注意的是，由于我们需要检测上凸壳最后加入的点是否合法，此时需要再次插入最左边的点 `textithull[0]` 进行判别。
>   - 时间复杂度 `O(nlogn)` ，空间复杂度 `O(n)` 。

```java
class Solution {
    
    public int[][] outerTrees(int[][] points) {
        int n = points.length;
        int s = 0;
        int[][] stack = new int[n << 1][];
        // x小的排前面，x一样的，y小的排前面
        Arrays.sort(points, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);
        // 生成下凸壳
        for (int i = 0; i < n; i++) {
            while (s > 1 && cross(stack[s - 2], stack[s - 1], points[i]) > 0) {
                s--;
            }
            stack[s++] = points[i];
        }
        // 生成上凸壳
        for (int i = n - 2; i >= 0; i--) {
            while (s > 1 && cross(stack[s - 2], stack[s - 1], points[i]) > 0) {
                s--;
            }
            stack[s++] = points[i];
        }
        // 去重返回
        Arrays.sort(stack, 0, s, (a, b) -> b[0] == a[0] ? b[1] - a[1] : b[0] - a[0]);
        n = 1;
        for (int i = 1; i < s; i++) {
            // 如果i点，x和y，与i-1点，x和y都一样
            // i点与i-1点，在同一个位置，此时，i点不保留
            if (stack[i][0] != stack[i - 1][0] || stack[i][1] != stack[i - 1][1]) {
                stack[n++] = stack[i];
            }
        }
        return Arrays.copyOf(stack, n);
    }
    
    // 叉乘的实现
    // 假设有a、b、c三个点，并且给出每个点的(x,y)位置
    // 从a到c的向量，在从a到b的向量的哪一侧？
    // 如果a到c的向量，在从a到b的向量右侧，返回正数
    // 如果a到c的向量，在从a到b的向量左侧，返回负数
    // 如果a到c的向量，和从a到b的向量重合，返回0
    public int cross(int[] a, int[] b, int[] c) {
        return (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1]);
    }
    
}
```
