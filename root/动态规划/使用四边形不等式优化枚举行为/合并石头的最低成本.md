# 标题

## 左老师课堂讲述

> - ***Question***
>   - 有 `N` 堆石头排成一排，第 `i` 堆中有 `stones[i]` 块石头。每次移动只能将相邻的 `2` 堆石头合并为一堆，而这个移动的成本为这 `2` 堆石头的总数。
>   - 找出把所有石头合并成一堆的最低成本。

---

## *Java*

> - ***动态规划***
>   - 设 `dp` 表中 `dp[L][R]` 表示 `stones[L ~ R]` 上的所有石头合并成一堆的最低成本，该表左下角不用填，因为递归是范围尝试模型，左不可能大于右，对角线上代表自己和自己合并成一堆，成本为0，倒数第二条对角线即为对应左边的两堆石头的总数相加。其余位置的依赖见注释。

```java
class Solution {
    
    public int dp(int[] stones) {
        if (stones == null || stones.length < 2) {
            return 0;
        }
        // 前缀和
        int[] preSum = new int[stones.length + 1];
        for (int i = 0; i < stones.length; ++i) {
            preSum[i + 1] = preSum[i] + stones[i];
        }
        int[][] dp = new int[stones.length][stones.length];
        // 从倒数第二行开始向上
        for (int left = stones.length - 2; left >= 0; --left) {
            // 从第二条主对角线开始
            for (int right = left + 1; right < stones.length; ++right) {
                // 对于每一个区域要合成一堆，我们之前肯定生成好的两堆，由于只能连续两堆合并，那么之前的堆就是左右分割开的，我们枚举所有左右堆的情况计算最小值即可
                // 对于stones[i ~ j]合并
                // 枚举stones[i ~ k] & stones[k + 1 ~ j]
                // 枚举stones[i ~ k + 1] & stones[k + 2 ~ j]
                // 枚举stones[i ~ k + 2] & stones[k + 3 ~ j]
                // ......
                int ans = Integer.MAX_VALUE;
                // 以左堆的结束位置为变量即可
                for (int leftEnd = left; leftEnd < right; ++leftEnd) {
                    ans = Math.min(ans, dp[left][leftEnd] + dp[leftEnd + 1][right]);
                }
                // 之前合成两堆所用的代价，还要加上合成当前堆的代价
                // 用前缀和求区间和，区间和就是合成当前堆的代价
                dp[left][right] = ans + (preSum[right + 1] - preSum[left]);
            }
        }
        return dp[0][stones.length - 1];
    }
    
}
```

> - ***动态规划 + 四边形不等式***
>   - 上面的动态规划中，每一个位置都需要枚举所有情况，太搞了。
>   - 我们给出结论：对于一个位置，如果其左侧位置最低成本使用的那两堆的划分点为 `i` ，即左侧边界，其下侧位置最低成本使用的那两堆的划分点为 `j` ，那么当前位置最低成本使用的划分点一定在 `i` 和 `j` 之间（闭区间）。

```java
class Solution {
    
    public int dp(int[] stones) {
        if (stones == null || stones.length < 2) {
            return 0;
        }
        int[] preSum = new int[stones.length + 1];
        for (int i = 0; i < stones.length; ++i) {
            preSum[i + 1] = preSum[i] + stones[i];
        }
        int[][] dp = new int[stones.length][stones.length];
        // best[i][j]表示dp[i][j]对应的最低成本最后一次合并时使用的那两堆石头在区间上的划分点位置
        int[][] best = new int[stones.length][stones.length];
        // 填第二条对角线
        for (int i = 0; i < stones.length - 1; ++i) {
            // preSum[i + 2] - preSum[i]
            dp[i][i + 1] = stones[i] + stones[i + 1];
            best[i][i + 1] = i;
        }
        // 倒数第三行开始
        for (int left = stones.length - 3; left >= 0; --left) {
            // 第三条对角线开始
            for (int right = left + 2; right < stones.length; ++right) {
                int ans = Integer.MAX_VALUE;
                // 用于记录切割位置
                int choose = -1;
                // 切割位置在指定区间内试
                for (int leftEnd = best[left][right - 1]; leftEnd <= best[left + 1][right]; ++leftEnd) {
                    int curCost = dp[left][leftEnd] + dp[leftEnd + 1][right];
                    // 如果当前划分方案的合并代价小于之前的
                    if (curCost < ans) {
                        // 更新
                        ans = curCost;
                        // 位置也更新
                        choose = leftEnd;
                    }
                }
                // 位置也要记录
                best[left][right] = choose;
                dp[left][right] = ans + (preSum[right + 1] - preSum[left]);
            }
        }
        return dp[0][stones.length - 1];
    }
    
}
```

---

> ***last change: 2023/1/31***

---
