# 最大二叉树

## [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

> - ***Question***
>   - 给定一个不重复的整数数组 `nums` 。最大二叉树可以用下面的算法从 `nums` 递归地构建:
>     - 创建一个根节点，其值为 nums 中的最大值。
>     - 递归地在最大值左边的子数组前缀上构建左子树。
>     - 递归地在最大值右边的子数组后缀上构建右子树。
>   - 返回 `nums` 构建的最大二叉树。
>   - ***tips:***
>     - `1 <= nums.length <= 1000`
>     - `0 <= nums[i] <= 1000`
>     - `nums` 中的所有整数互不相同

---

## *Java*

> - ***递归***

```java
// 普通二叉树节点
class TreeNode {

    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }

}

class Solution {

    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return construct(nums, 0, nums.length - 1);
    }

    public TreeNode construct(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        int best = left;
        for (int i = left + 1; i <= right; ++i) {
            if (nums[i] > nums[best]) {
                best = i;
            }
        }
        TreeNode node = new TreeNode(nums[best]);
        node.left = construct(nums, left, best - 1);
        node.right = construct(nums, best + 1, right);
        return node;
    }

}
```

---

> ***last change: 2024/3/27***

---
