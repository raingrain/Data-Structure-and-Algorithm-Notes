# 不含连续1的非负整数

## [600. 不含连续1的非负整数](https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/)

> - ***Question***
>   - 给定一个正整数 `n` ，请你统计在 `[0, n]` 范围的非负整数中，有多少个整数的二进制表示中不存在连续的 `1` 。
>   - ***tips:***
>     - `1 <= n <= 10^9`

---

## *Java*

> - ***数位DP***

```java
class Solution {
    
    public int findIntegers(int n) {
        int i = 31;
        for (; i >= 0; i--) {
            if ((n & (1 << i)) != 0) {
                break;
            }
        }
        // for循环出来之后，i表示，n最高位的1，在哪？
        // 从这个位置，往右边低位上走！
        int[][][] dp = new int[2][2][i + 1];
        return recursion(0, 0, i, n, dp);
    }
    
    // pre : 第i+1位做的决定，0还是1
    // alreadyLess : 之前的决定，是不是已经导致你到index的时候，已经比n小了！是为1，不是为0
    // 在 第i+1位做的决定 是pre的情况下，从index位开始，往后都做决定！
   // 但是，不能有相邻的1，请问有多少决定！返回！
    private int recursion(int pre, int alreadyLess, int index, int num, int[][][] dp) {
        if (index == -1) {
            return 1;
        }
        if (dp[pre][alreadyLess][index] != 0) {
            return dp[pre][alreadyLess][index];
        }
        int ans = 0;
        int curLessOrMore = Math.max(alreadyLess, (num & (1 << index)) != 0 ? 1 : 0);
        if (pre == 1) {
            // 只能做0的决定，然后去往index-1位置
            ans = recursion(0, curLessOrMore, index - 1, num, dp);
        } else {
            if ((num & (1 << index)) == 0 && alreadyLess == 0) {
                // 可能性1，只能做0的决定，因为当前位置是1且之前做的决定的部分不小于n的同样部分
                ans = recursion(0, alreadyLess, index - 1, num, dp);
            } else {
                // 可能性2，当前位置能做1（因为现在位置上也是1，alreadyLess直接传递）
                // 当前位置只能做0，和当前位置不一样要再评估一下
                ans = recursion(1, alreadyLess, index - 1, num, dp) + recursion(0, curLessOrMore, index - 1, num, dp);
            }
        }
        dp[pre][alreadyLess][index] = ans;
        return ans;
    }
    
}
```

---

> ***last change: 2023/4/30***

---
