# 正则表达式匹配

## [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

## [剑指 Offer 19. 正则表达式匹配](https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

> - ***Question***
>   - 给你一个字符串 `s` 和一个字符规律 `p` ，请你来实现一个支持 `.` 和 `*` 的正则表达式匹配：
>     - `.` 匹配任意单个字符。
>     - `*` 匹配零个或多个前面的那一个元素。
>   - 所谓匹配，是要涵盖整个字符串 `s` 的，而不是部分字符串。
>   - ***tips:***
>     - `s` 可能为空，且只包含从 `a-z` 的小写字母
>     - `p` 可能为空，且只包含从 `a-z` 的小写字母以及字符 `.` 和 `*` ，无连续的 `*`

---

## *Java*

> - ***记忆化搜索 + 斜率优化***

```java
class Solution {
    
    public boolean isMatch(String s, String e) {
        if (s == null || e == null) {
            return false;
        }
        char[] str = s.toCharArray();
        char[] exp = e.toCharArray();
        // 检查有没有违规
        if (!isValid(str, exp)) {
            return false;
        }
        // dp[i][j] = 0, 没算过
        // dp[i][j] = -1 算过，返回值是false
        // dp[i][j] = 1 算过，返回值是true
        int[][] dp = new int[str.length + 1][exp.length + 1];
        return recursion(str, exp, 0, 0, dp);
    }
    
    // 检查给定串是否违规
    private boolean isValid(char[] str, char[] exp) {
        // str中不能有模式符
        for (char c : str) {
            if (c == '*' || c == '.') {
                return false;
            }
        }
        // exp中*不能开头且不能连续
        for (int i = 0; i < exp.length; i++) {
            if (exp[i] == '*' && (i == 0 || exp[i - 1] == '*')) {
                return false;
            }
        }
        return true;
    }
    
    // 返回exp[ei...]能不能匹配出str[si...]
    private boolean recursion(char[] str, char[] exp, int si, int ei, int[][] dp) {
        if (dp[si][ei] != 0) {
            return dp[si][ei] == 1;
        }
        boolean ans = false;
        if (ei == exp.length) {
            // 正则表达式已经遍历完成，目标串必须匹配完才能算全部匹配上，有一个没匹配完就算失败
            ans = si == str.length;
        } else {
            // 正则表达式还有
            // 根据ei的下一个位置是不是*进行讨论
            if (ei + 1 == exp.length || exp[ei + 1] != '*') {
                // 当ei是最后一个位置或者ei不是最后一个位置且下一个位置不是*时
                // 首先目标串必须还有字符
                // 然后exp的当前位置要和目标串当前位置相等或者是‘.’
                // 如
                // a b
                // c ？
                // 不行，c配不上a
                // 或
                // a b
                // . ？
                // 可以，用.配a
                // 或
                // a b
                // a ？
                // 可以，用a配a
                ans = si != str.length && (exp[ei] == str[si] || exp[ei] == '.') && recursion(str, exp, si + 1, ei + 1, dp);
            } else {
                // 当ei的下一个位置是*时
                if (si == str.length) {
                    // 如果目标串遍历完成
                    // 那么将当前字符和*匹配成0个，去看正则表达式的下下个字符
                    ans = recursion(str, exp, si, ei + 2, dp);
                } else {
                    // 如果目标串还没遍历完成
                    if (str[si] != exp[ei] && exp[ei] != '.') {
                        // 如果当前位置不相等且当前模式不是'.'
                        // a b
                        // c *
                        // 目标串不动，当前模式匹配0个，去下下一个字符匹配
                        ans = recursion(str, exp, si, ei + 2, dp);
                    } else {
                        // 如果当前位置相等
                        // a  a  a  a  a  b
                        // 12 13 14 15 16 17
                        // a  *
                        // 29 30
                        // 若目标串来到13，正则来到29
                        // 那么dp[13][29]依赖dp[13][31] dp[14][31] dp[15][31] dp[16][31] dp[17][31]
                        // 这表示将a*匹配成0个a到4个a
                        // 同理dp[12][29]依赖dp[12~17][31] = dp[12][31] + dp[13][29]
                        // 以下或表示斜率优化
                        ans = recursion(str, exp, si, ei + 2, dp) || recursion(str, exp, si + 1, ei, dp);
                        // 另外一种例子
                        // a  b
                        // 12 13
                        //    a  *
                        //    14 15
                        // dp[13][14] = dp[13][16]
                        // dp[12][14] = dp[12][16] + dp[13][16] = dp[12][16] + dp[13][14]
                    }
                }
            }
        }
        // 匹配成功是1否则是-1
        dp[si][ei] = ans ? 1 : -1;
        return ans;
    }
    
}
```

---

> ***last change: 2023/4/6***

---
