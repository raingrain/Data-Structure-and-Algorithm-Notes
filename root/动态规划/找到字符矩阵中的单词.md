# 找到字符矩阵中的单词

## 左老师课堂讲述

> - ***Question***
>   - 给定一个 `char[][] matrix` ，也就是 `char` 类型的二维数组，再给定一个字符串 `word` ，可以从任何一个某个位置出发，可以走上下左右，能不能找到 `word` ？
>   - 设定1：可以走重复路的情况下，返回能不能找到。
>   - 设定2：不可以走重复路的情况下，返回能不能找到。
>   - 写出两种设定下的代码。

---

## *Java*

> - ***暴力递归***
>   - 因为可以从每个位置开始，那么主函数内只要对每一个位置过一遍函数 `f(matrix, i, j, str, 0)` 即可，对于所有的位置，只要有一个为真，那么就返回真。

```java
class Solution {
    
    // 能走走过的路
    // 从matrix[i][j]位置开始走，能不能走出str[k...]
    public static boolean canLoop(char[][] matrix, int i, int j, char[] str, int k) {
        if (k == str.length) {
            return true;
        }
        // 越界或者当前字符不等于需要字符
        if (i == -1 || i == matrix.length || j == -1 || j == matrix[0].length || matrix[i][j] != str[k]) {
            return false;
        }
        return canLoop(matrix, i + 1, j, str, k + 1) || canLoop(matrix, i - 1, j, str, k + 1) || canLoop(matrix, i, j + 1, str, k + 1) || canLoop(matrix, i, j - 1, str, k + 1);
    }
    
    // 不能走走过的路
    public static boolean noLoop(char[][] matrix, int i, int j, char[] str, int k) {
        if (k == str.length) {
            return true;
        }
        // matrix[i][j] == 0的话，matrix[i][j] != str[k]
        if (i == -1 || i == matrix.length || j == -1 || j == matrix[0].length || matrix[i][j] != str[k]) {
            return false;
        }
        // 标记为访问过
        matrix[i][j] = 0;
        // 深度优先遍历
        boolean ans = canLoop(matrix, i + 1, j, str, k + 1) || canLoop(matrix, i - 1, j, str, k + 1) || canLoop(matrix, i, j + 1, str, k + 1) || canLoop(matrix, i, j - 1, str, k + 1);
        // 恢复现场
        matrix[i][j] = str[k];
        return ans;
    }
    
}
```

---

> ***last change: 2023/4/1***

---
