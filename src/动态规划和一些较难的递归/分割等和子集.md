# 分割等和子集

## [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

## [剑指 Offer II 101. 分割等和子集](https://leetcode.cn/problems/NUPfPr/)

> - ***Question***
>   - 给你一个只包含正整数的非空数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
>   - ***tips:***
>     - `1 <= nums.length <= 200`
>     - `1 <= nums[i] <= 100`

---

## *Java*

> - ***动态规划***
>   - 01背包问题。

```java
class Solution {
    
    public boolean canPartition(int[] nums) {
        if (nums.length < 2) {
            return false;
        }
        // 总和
        // 最大数
        int sum = 0, maxNum = 0;
        for (int num : nums) {
            sum += num;
            maxNum = Math.max(maxNum, num);
        }
        // 偶数才能分割
        if (sum % 2 != 0) {
            return false;
        }
        // 要分割出的子集和
        int target = sum / 2;
        // 最大值大于子集和，必定有一个子集会包括它，那就分不出
        if (maxNum > target) {
            return false;
        }
        // dp[i][j]表示nums[0~i]下标范围内能不能选出一个子集和为j
        boolean[][] dp = new boolean[nums.length][target + 1];
        // 不选
        for (int i = 0; i < nums.length; i++) {
            dp[i][0] = true;
        }
        // 只选nums[0]，之前的都不行，因为[0-0]上选只能是0或者nums[0]
        dp[0][nums[0]] = true;
        for (int i = 1; i < nums.length; i++) {
            for (int j = 1; j <= target; j++) {
                if (j >= nums[i]) {
                    // 对于当前数字，可选可不选
                    // 只要有一个为true
                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - nums[i]];
                } else {
                    // 要选取的和小于当前数字，不能选当前数字，因此看前一个位置
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        // 整个数组上能不能分成和为target的，那么剩下那个和一样，能够分割等和子集
        return dp[nums.length - 1][target];
    }
    
}
```

---

> ***last change: 2023/4/21***

---
