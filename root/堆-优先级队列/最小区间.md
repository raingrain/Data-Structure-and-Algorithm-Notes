# 最小区间

## [632. 最小区间](https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/)

> - ***Question***
>   - 你有 `k` 个非递减排列的整数列表。找到一个最小区间，使得 `k` 个列表中的每个列表至少有一个数包含在其中。
>   - 我们定义如果 `b - a < d - c` 或者在 `b - a == d - c` 时 `a < c` ，则区间 `[a, b]` 比 `[c, d]` 小。
>   - ***tips:***
>     - `nums.length == k`
>     - `1 <= k <= 3500`
>     - `1 <= nums[i].length <= 50`
>     - `-10^5 <= nums[i][j] <= 10^5`
>     - `nums[i]` 按非递减顺序排列

---

## *Java*

> - ***小根堆***

```java
class Solution {
    
    // [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
    // 0 4 5 -> [0, 5]
    // 4 5 9 -> [0, 5]
    // 5 9 10 -> [0, 5]
    // 9 10 18 -> [0, 5]
    // 10 12 18 -> [0, 5]
    // 12 15 18 -> [0, 5]
    // 15 18 20 -> [0, 5]
    // 18 20 24 -> [0, 5]
    // 20 22 24 -> [20, 24] 更窄的出现了，更新
    public int[] smallestRange(List<List<Integer>> nums) {
        // 一个小根堆
        // 按照数值大小升序排序，数值相同按照数组编号排序
        // 堆中一个数组只能有一个数字
        TreeSet<Node> orderSet = new TreeSet<>((o1, o2) -> o1.value != o2.value ? o1.value - o2.value : o1.arrayID - o2.arrayID);
        // 先将所有数组的第一个数放进去
        for (int i = 0; i < nums.size(); i++) {
            orderSet.add(new Node(nums.get(i).get(0), i, 0));
        }
        // 有没有设置过区间
        boolean set = false;
        // 记录答案
        int left = 0;
        int right = 0;
        // 当有序表里面的元素不满足数组个数时，说明上一轮中有一个数组遍历完了，没有把数字加进去
        while (orderSet.size() == nums.size()) {
            // 有序表中最小值
            Node min = orderSet.first();
            // 有序表中最大值
            Node max = orderSet.last();
            // 没有设置过区间或找到一个更小的区间就更新答案
            // 相同的不更新，这这样记录更早的答案
            if (!set || (max.value - min.value < right - left)) {
                set = true;
                left = min.value;
                right = max.value;
            }
            // 抓出来
            min = orderSet.pollFirst();
            assert min != null;
            // 它所在数组的下一个进堆
            int arrayID = min.arrayID;
            int index = min.index + 1;
            // 越界就不加
            if (index != nums.get(arrayID).size()) {
                orderSet.add(new Node(nums.get(arrayID).get(index), arrayID, index));
            }
        }
        return new int[]{left, right};
    }
    
    private static class Node {
        
        // 值是多少
        public int value;
        // 在几号数组中
        public int arrayID;
        // 位置是多少
        public int index;
        
        public Node(int value, int arrayID, int index) {
            this.value = value;
            this.arrayID = arrayID;
            this.index = index;
        }
        
    }
    
}
```

---

> ***last change: 2023/4/9***

---
