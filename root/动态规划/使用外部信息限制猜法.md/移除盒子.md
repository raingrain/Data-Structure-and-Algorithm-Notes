# 移除盒子

## [546. 移除盒子](https://leetcode.cn/problems/remove-boxes/)

> - ***Question***
>   - 给出一些不同颜色的盒子 `boxes` ，盒子的颜色由不同的正数表示。你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 `k` 个盒子（ `k >= 1` ），这样一轮之后你将得到 `k * k` 个积分。
返回你能获得的最大积分和。
>   - ***tips:***
>     - `1 <= boxes.length <= 100`
>     - `1 <= boxes[i] <= 100`

---

## *Java*

> - ***记忆化搜索***

```java
class Solution {
    
    public static int removeBoxes(int[] boxes) {
        // 在0~N上消除，前面有0个数字
        return recursion(boxes, new int[boxes.length][boxes.length][boxes.length], 0, boxes.length - 1, 0);
    }
    
    // arr[L...R]消除，而且前面跟着K个arr[L]这个数
    // 返回：所有东西都消掉，最大得分
    public static int recursion(int[] boxes, int[][][] dp, int left, int right, int k) {
        if (left > right) {
            return 0;
        }
        if (dp[left][right][k] > 0) {
            return dp[left][right][k];
        }
        // 找到开头，
        // 1,1,1,1,1,5
        // 3 4 5 6 7 8
        //         !
        int last = left;
        while (last + 1 <= right && boxes[last + 1] == boxes[left]) {
            last++;
        }
        // K个1     (k + last - left) last
        int pre = k + last - left;
        // 第一片连续的1直接合并，所以最后传0
        int ans = (pre + 1) * (pre + 1) + recursion(boxes, dp, last + 1, right, 0);
        for (int i = last + 2; i <= right; i++) {
            // boxes[i - 1] != boxes[left]排除连续的1中除第一个外的
            if (boxes[i] == boxes[left] && boxes[i - 1] != boxes[left]) {
                // last + 1, i - 1上自己玩没
                // i, right上和前面的pre+1个合并，这片新的1下一轮会走最开始的ans
                ans = Math.max(ans, recursion(boxes, dp, last + 1, i - 1, 0) + recursion(boxes, dp, i, right, pre + 1));
            }
        }
        dp[left][right][k] = ans;
        return ans;
    }
    
}
```

---

> ***last change: 2023/2/4***

---
