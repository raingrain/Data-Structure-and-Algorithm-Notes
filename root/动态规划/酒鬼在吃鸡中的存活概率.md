# 酒鬼在吃鸡中的存活概率

## 来源未知

> - ***Question***
>   - 有一个规模为 `row` 行 `column` 列的矩阵区域，规定左上角为坐标原点，向左向下为正方向。
>   - 有一个酒鬼初始位于其中的 `(x, y)` 位置。
>   - 这个区域内为安全区，区域外为毒区，酒鬼走出区域外立即死亡。
>   - 酒鬼由于醉酒，他朝上下左右四个方向迈出一步是等可能的。
>   - 问酒鬼在只能走 `k` 步的条件下，走完 `k` 步后存活下来（即还在安全区内，没有走出区域外）的概率是多少。

---

## *Java*

> - ***暴力递归***
>   - 参考[中国象棋棋盘上马到达指定位置方法数](中国象棋棋盘上马到达指定位置方法数.md)，对于有不同方向选择的问题，在递归上尝试每一种方向最后返回所有方向的情况的相加。
>   - 本题注意一个数学上的思路，假设安全区无限大，在只能走k步的限制下，酒鬼能走出的所有情况为 `4` 的 `k` 次方个，用递归计算出存活的情况有几种，两者相除即可得到答案。

```java
class Solution {
    
    public double live(int row, int col, int x, int y, int k) {
        return (double) recursion(row, col, x, y, k) / Math.pow(4, k);
    }
    
    // 目前在i，j位置，还有rest步要走
    // 返回存活的走法个数
    public long recursion(int row, int col, int i, int j, int rest) {
        if (i < 0 || i >= row || j < 0 || j >= col) {
            return 0;
        }
        if (rest == 0) {
            return 1;
        }
        long up = recursion(row, col, i - 1, j, rest - 1);
        long down = recursion(row, col, i + 1, j, rest - 1);
        long left = recursion(row, col, i, j - 1, rest - 1);
        long right = recursion(row, col, i, j + 1, rest - 1);
        return up + down + left + right;
    }
    
}
```

> - ***动态规划***
>   - 一个很简单的只依赖下一行的三维动态规划，注意使用 `pick` 函数来处理越界情况。

```java
class Solution {
    
    public double live(int row, int col, int x, int y, int k) {
        return dp(row, col, x, y, k);
    }
    
    public double dp(int row, int col, int x, int y, int k) {
        long[][][] dp = new long[row][col][k + 1];
        for (int i = 0; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                dp[i][j][0] = 1;
            }
        }
        for (int rest = 1; rest <= k; ++rest) {
            for (int i = 0; i < row; ++i) {
                for (int j = 0; j < col; ++j) {
                    long up = pick(dp, row, col, i - 1, j, rest - 1);
                    long down = pick(dp, row, col, i + 1, j, rest - 1);
                    long left = pick(dp, row, col, i, j - 1, rest - 1);
                    long right = pick(dp, row, col, i, j + 1, rest - 1);
                    dp[i][j][rest] = up + down + left + right;
                }
            }
        }
        return (double) dp[x][y][k] / Math.pow(4, k);
    }
    
    // 用pick函数处理越界情况
    public long pick(long[][][] dp, int row, int col, int i, int j, int rest) {
        return (i < 0 || i >= row || j < 0 || j >= col) ? 0 : dp[i][j][rest];
    }
    
}
```

---

> ***last change: 2023/1/27***

---
