# 会议系列问题

## [1353. 最多可以参加的会议数目](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/)

> - ***Question 1***
>   - 给你一个数组 `events` ，其中 `events[i] = [startDayi, endDayi]` ，表示会议 `i` 开始于 `startDayi` ，结束于 `endDayi` 。
>   - 你可以在满足 `startDayi <= d <= endDayi` 中的任意一天 `d` 参加会议 `i` 一天只能参加一个会议。
>   - 请你返回你可以参加的最大会议数目。
>   - ***tips:***
>     - `1 <= events.length <= 10^5`
>     - `events[i].length == 2`
>     - `1 <= startDayi <= endDayi <= 10^5`

## 左老师课堂讲述

> - ***Question 2***
>   - 给定 `int[][] meetings` ， `meetings[i][0]` 表示会议的截止时间， `meetings[i][0]` 表示会议的收益。
>   - 一开始的时间是 `0` 。
>   - 任何会议都持续 `10` 的时间，但是一个会议一定要在该会议截止时间之前开始，包括截止时间。
>   - 只有一个会议室，任何会议不能共用会议室，一旦一个会议被正确安排，将获得这个会议的收益。
>   - 请返回最大的收益。

## 通维数码

> - ***Question 3***
>   - 给定每个会议给定开始和结束时间。后面的会议如果跟前面的会议有任何冲突，完全取消冲突的、之前的会议，安排当前的。给定一个会议数组，返回安排的会议列表。

---

## *Java*

> - ***Question 1: 贪心***  
>   - 如果这道题要求的是求一种方案中可以参加的最大会议数目，那么直接把数组按照结束时间升序排序，然后依次选取即可，主要贪心策略指每一次都选择结束时间最早的会议。
>   - 但是这一题的结果甚至会议是包括重复的，既参加的会议中数目最多的各个方案中的合集，我们先按照会议开始时间排序，然后用一个优先级队列模拟每一天的会议日程表，每一天都要加入当天开始的会议，然后清除过期会议，最后队列不为空就开一个会议，每次循环都进入到下一天，天数从 `1` 开始。

```java
class Solution {

    public int maxEvents(int[][] events) {
        return maxEventsByGreedy(events);
    }

    public int maxEventsByGreedy(int[][] events) {
        // 把数组排成开始时间早放前面
        // 比较器可以直接写成 (o1, o2) -> o1[0] - o2[0]
        Arrays.sort(events, new MyComparator());
        // 存储结束时间早的会议
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        // 时间线
        int time = events[0][0];
        // 答案
        int ans = 0;
        // 数组下标
        int index = 0;
        while (index < events.length || !queue.isEmpty()) {
            // 每一天都先把从当天开始的会议加进优先级队列
            while (index < events.length && events[index][0] == time) {
                queue.offer(events[index][1]);
                index++;
            }
            // 有没有过期会议
            while (!queue.isEmpty() && queue.peek() < time) {
                queue.poll();
            }
            // 每一天的计划中还有会议就参加
            if(!queue.isEmpty()) {
                queue.poll();
                ans++;
            }
            // 新的一天
            time++;
        }
        return ans;
    }
    
    // 构造比较器，按照开始时间升序排列
    public class MyComparator implements Comparator<int[]> {
        @Override
        public int compare(int[] o1, int[] o2) {
            return o1[0] - o2[0];
        }
    } 

}
```

> - ***Question 2: 贪心 + 排序 + 小根堆***

```java
class Solution {
    
    public static int maxScore(int[][] meetings) {
        // 按照截止时间由小到大排序，截止时间相等顺序无所谓
        Arrays.sort(meetings, Comparator.comparingInt(a -> a[0]));
        // 小根堆
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        // 当前结束时间
        int time = 0;
        for (int[] meeting : meetings) {
            // 首先会议应该紧凑安排
            // 之前的任务完成时所需要的时间
            // meeting[0]>=time+10说明当前任务可以安排
            if (time + 10 <= meeting[0]) {
                // 收益入堆
                heap.offer(meeting[1]);
                time += 10;
            } else if (!heap.isEmpty() && heap.peek() < meeting[1]) {
                // 不能安排当前任务，但我们看看堆中有没有收益比当前小的，如果有我们可以选择不做这个任务，而做当前任务，即被替换的任务所需要的完成时间内被替换成了当前任务
                heap.poll();
                heap.offer(meeting[1]);
            }
        }
        // 统计堆中所有收益即为答案
        int ans = 0;
        while (!heap.isEmpty()) {
            ans += heap.poll();
        }
        return ans;
    }
    
}
```

> - ***Question 3:***
>   - 排序后，从右往左遍历，如果指定时间区间上累加和为 `0` 说明没安排过，那就安排当前会议，答案记录，当前会议的时间区间在线段树上全加一。如果不为 `0` 说明安排过，答案不记录，但当前会议的时间区间在线段树上全加一，这是为了实现后面的会取消前面的机制。

```java
class Solution {

    // 彻底暴力做的！
    // 对数器！
    public static ArrayList<int[]> arrange1(int[][] meetings) {
        int max = 0;
        for (int[] meeting : meetings) {
            max = Math.max(max, meeting[1]);
        }
        boolean[] occupy = new boolean[max + 1];
        ArrayList<int[]> ans = new ArrayList<>();
        for (int i = meetings.length - 1; i >= 0; i--) {
            int[] cur = meetings[i];
            boolean add = true;
            for (int j = cur[0]; j < cur[1]; j++) {
                if (occupy[j]) {
                    add = false;
                    break;
                }
            }
            if (add) {
                ans.add(cur);
            }
            for (int j = cur[0]; j < cur[1]; j++) {
                occupy[j] = true;
            }
        }
        return ans;
    }

    public static ArrayList<int[]> arrange2(int[][] meetings) {
        int n = meetings.length;
        int[] rank = new int[n << 1];
        for (int i = 0; i < meetings.length; i++) {
            rank[i] = meetings[i][0];
            rank[i + n] = meetings[i][1] - 1;
        }
        Arrays.sort(rank);
        SegmentTree st = new SegmentTree(n << 1);
        ArrayList<int[]> ans = new ArrayList<>();
        for (int i = meetings.length - 1; i >= 0; i--) {
            int[] cur = meetings[i];
            int from = rank(rank, cur[0]);
            int to = rank(rank, cur[1] - 1);
            if (st.sum(from, to) == 0) {
                ans.add(cur);
            }
            st.add(from, to, 1);
        }
        return ans;
    }

    public static int rank(int[] rank, int num) {
        int l = 0;
        int r = rank.length - 1;
        int m = 0;
        int ans = 0;
        while (l <= r) {
            m = (l + r) / 2;
            if (rank[m] >= num) {
                ans = m;
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        return ans + 1;
    }

    public static class SegmentTree {

        private int n;
        private int[] sum;
        private int[] lazy;

        public SegmentTree(int size) {
            n = size + 1;
            sum = new int[n << 2];
            lazy = new int[n << 2];
            n--;
        }

        private void pushUp(int rt) {
            sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
        }

        private void pushDown(int rt, int ln, int rn) {
            if (lazy[rt] != 0) {
                lazy[rt << 1] += lazy[rt];
                sum[rt << 1] += lazy[rt] * ln;
                lazy[rt << 1 | 1] += lazy[rt];
                sum[rt << 1 | 1] += lazy[rt] * rn;
                lazy[rt] = 0;
            }
        }

        public void add(int L, int R, int C) {
            add(L, R, C, 1, n, 1);
        }

        private void add(int L, int R, int C, int l, int r, int rt) {
            if (L <= l && r <= R) {
                sum[rt] += C * (r - l + 1);
                lazy[rt] += C;
                return;
            }
            int mid = (l + r) >> 1;
            pushDown(rt, mid - l + 1, r - mid);
            if (L <= mid) {
                add(L, R, C, l, mid, rt << 1);
            }
            if (R > mid) {
                add(L, R, C, mid + 1, r, rt << 1 | 1);
            }
            pushUp(rt);
        }

        public int sum(int L, int R) {
            return query(L, R, 1, n, 1);
        }

        private int query(int L, int R, int l, int r, int rt) {
            if (L <= l && r <= R) {
                return sum[rt];
            }
            int mid = (l + r) >> 1;
            pushDown(rt, mid - l + 1, r - mid);
            int ans = 0;
            if (L <= mid) {
                ans += query(L, R, l, mid, rt << 1);
            }
            if (R > mid) {
                ans += query(L, R, mid + 1, r, rt << 1 | 1);
            }
            return ans;
        }

    }

    // 为了测试
    public static int[][] randomMeeting(int len, int time) {
        int[][] meetings = new int[len][2];
        for (int i = 0; i < len; i++) {
            int a = (int) (Math.random() * (time + 1));
            int b = (int) (Math.random() * (time + 1));
            if (a == b) {
                b++;
            }
            meetings[i][0] = Math.min(a, b);
            meetings[i][1] = Math.max(a, b);
        }
        return meetings;
    }

    // 为了测试
    public static int[][] copyMeetings(int[][] meetings) {
        int len = meetings.length;
        int[][] ans = new int[len][2];
        for (int i = 0; i < len; i++) {
            ans[i][0] = meetings[i][0];
            ans[i][1] = meetings[i][1];
        }
        return ans;
    }

    // 为了测试
    public static boolean equal(ArrayList<int[]> arr1, ArrayList<int[]> arr2) {
        if (arr1.size() != arr2.size()) {
            return false;
        }
        for (int i = 0; i < arr1.size(); i++) {
            int[] a = arr1.get(i);
            int[] b = arr2.get(i);
            if (a[0] != b[0] || a[1] != b[1]) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        int n = 100;
        int t = 5000;
        int testTime = 20000;
        System.out.println("测试开始");
        for (int i = 0; i < testTime; i++) {
            int len = (int) (Math.random() * n) + 1;
            int[][] meetings1 = randomMeeting(len, t);
            int[][] meetings2 = copyMeetings(meetings1);
            ArrayList<int[]> ans1 = arrange1(meetings1);
            ArrayList<int[]> ans2 = arrange2(meetings2);
            if (!equal(ans1, ans2)) {
                System.out.println("出错了!");
                System.out.println(ans1.size());
                System.out.println(ans2.size());
                System.out.println("====");
            }
        }
        System.out.println("测试结束");
    }

}
```

---

> ***last change: 2023/5/15***

---
