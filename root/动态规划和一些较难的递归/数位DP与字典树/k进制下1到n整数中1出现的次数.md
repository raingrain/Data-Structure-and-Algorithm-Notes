# k进制下1到n整数中1出现的次数

## [233. 数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/)

## [剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

> - ***Question 1***
>   - 输入一个整数 `n` ，求 `1 ~ n` 这 `n` 个整数的十进制表示中1出现的次数。
>   - 例如，输入 `12` ， `1 ~ 12` 这些整数中包含 `1` 的数字有 `1, 10, 11, 12` ， `1` 一共出现了 `5` 次。
>   - ***tips:***
>     - `1 <= n < 2^31`

## [3. k进制下一的个数](https://www.nowcoder.com/exam/test/69079544/detail?pid=33701596)

> - ***Question 2***
>   - 定义 `F(m, k)` 为 `k` 进制下 `1 ~ m` 中 `1` 出现的次数。给定 `k` 和 `n` ，求使得 `F(m, k) >= n` 最小的 `m` 是多少。

---

## *Java*

> - ***Question 1: 数位DP***

```java
class Solution {
    
    public int countDigitOne(int num) {
        if (num < 1) {
            return 0;
        }
        // 获取数字长度
        int len = getLenOfNum(num);
        // 1 ~ (0,...,9)都只有1个1
        if (len == 1) {
            return 1;
        }
        // num 13625
        // temp 10000
        // num 7872328738273
        // temp 1000000000000
        int temp = (int) Math.pow(10, len - 1);
        // 第一位数字是几
        int first = num / temp;
        // 第一位上有几个1
        int firstOneNum = first == 1 ? num % temp + 1 : temp;
        // 剩下的位上有几个1
        int otherOneNum = first * (len - 1) * (temp / 10);
        // 如1364分为1~364和365~1364
        // 我们计算365到1364，分开计算每个数字能给个十百千位上贡献几个1
        // 对于千位为365
        // 对于百位，我们发现在十位和个位上0~9随意选择有10*10个
        // 对于十位，我们在百位和个位上随意选择有100
        // 个位在百位和十位上选择，也一样
        // 即选好后只有千位上只有一个选择能让这个数字在要求的范围内
        // 对于365到5364
        // 我们要手动计算这些的话
        // 分成365~1364，1365~2364，2365~3364，3365~4363，4365~5364这5个组，刚刚的结论每个组的结果都一样通项公式乘5即可
        // 后者的1就是firstOneNum + otherOneNum
        // 剩下的部分递归去算
        return firstOneNum + otherOneNum + countDigitOne(num % temp);
    }
    
    private int getLenOfNum(int num) {
        int len = 0;
        while (num != 0) {
            len++;
            num /= 10;
        }
        return len;
    }
    
}
```

> - ***Question 2: 数位DP***

```java
public class Solution {
    
    public static long minM(int n, int k) {
        int len = bits(n, k);
        long l = 1;
        long r = power(k, len + 1);
        long ans = r;
        while (l <= r) {
            long m = l + ((r - l) >> 1);
            if (ones(m, k) >= n) {
                ans = m;
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        return ans;
    }
    
    public static int bits(long num, int k) {
        int len = 0;
        while (num != 0) {
            len++;
            num /= k;
        }
        return len;
    }
    
    public static long power(long base, int power) {
        long ans = 1;
        while (power != 0) {
            if ((power & 1) != 0) {
                ans *= base;
            }
            base *= base;
            power >>= 1;
        }
        return ans;
    }
    
    public static long ones(long num, int k) {
        int len = bits(num, k);
        if (len <= 1) {
            return len;
        }
        long offset = power(k, len - 1);
        long first = num / offset;
        long curOne = first == 1 ? (num % offset) + 1 : offset;
        long restOne = first * (len - 1) * (offset / k);
        return curOne + restOne + ones(num % offset, k);
    }
    
}
```

---

> ***last change: 2023/5/5***

---
