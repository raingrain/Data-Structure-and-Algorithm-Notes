# 会议系列问题

## [1353. 最多可以参加的会议数目](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/)

> - ***Question 1***
>   - 给你一个数组 `events` ，其中 `events[i] = [startDayi, endDayi]` ，表示会议 `i` 开始于 `startDayi` ，结束于 `endDayi` 。
>   - 你可以在满足 `startDayi <= d <= endDayi` 中的任意一天 `d` 参加会议 `i` 一天只能参加一个会议。
>   - 请你返回你可以参加的最大会议数目。
>   - ***tips:***
>     - `1 <= events.length <= 10^5`
>     - `events[i].length == 2`
>     - `1 <= startDayi <= endDayi <= 10^5`

## 左老师课堂讲述

> - ***Question 2***
>   - 给定 `int[][] meetings` ， `meetings[i][0]` 表示会议的戒截止时间， `meetings[i][0]` 表示会议的收益。
>   - 一开始的时间是 `0` 。
>   - 任何会议都持续 `10` 的时间，但是一个会议一定要在该会议截止时间之前开始，包括截止时间。
>   - 只有一个会议室，任何会议不能共用会议室，一旦一个会议被正确安排，将获得这个会议的收益。
>   - 请返回最大的收益。

---

## *Java*

> - ***Question 1: 贪心***  
>   - 如果这道题要求的是求一种方案中可以参加的最大会议数目，那么直接把数组按照结束时间升序排序，然后依次选取即可，主要贪心策略指每一次都选择结束时间最早的会议。
>   - 但是这一题的结果甚至会议是包括重复的，既参加的会议中数目最多的各个方案中的合集，我们先按照会议开始时间排序，然后用一个优先级队列模拟每一天的会议日程表，每一天都要加入当天开始的会议，然后清除过期会议，最后队列不为空就开一个会议，每次循环都进入到下一天，天数从 `1` 开始。

```java
class Solution {

    public int maxEvents(int[][] events) {
        return maxEventsByGreedy(events);
    }

    public int maxEventsByGreedy(int[][] events) {
        // 把数组排成开始时间早放前面
        // 比较器可以直接写成 (o1, o2) -> o1[0] - o2[0]
        Arrays.sort(events, new MyComparator());
        // 存储结束时间早的会议
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        // 时间线
        int time = events[0][0];
        // 答案
        int ans = 0;
        // 数组下标
        int index = 0;
        while (index < events.length || !queue.isEmpty()) {
            // 每一天都先把从当天开始的会议加进优先级队列
            while (index < events.length && events[index][0] == time) {
                queue.offer(events[index][1]);
                index++;
            }
            // 有没有过期会议
            while (!queue.isEmpty() && queue.peek() < time) {
                queue.poll();
            }
            // 每一天的计划中还有会议就参加
            if(!queue.isEmpty()) {
                queue.poll();
                ans++;
            }
            // 新的一天
            time++;
        }
        return ans;
    }
    
    // 构造比较器，按照开始时间升序排列
    public class MyComparator implements Comparator<int[]> {
        @Override
        public int compare(int[] o1, int[] o2) {
            return o1[0] - o2[0];
        }
    } 

}
```

> - ***Question 2: 贪心 + 排序 + 小根堆***

```java
class Solution {
    
    public static int maxScore(int[][] meetings) {
        // 按照截止时间由小到大排序，截止时间相等顺序无所谓
        Arrays.sort(meetings, Comparator.comparingInt(a -> a[0]));
        // 小根堆
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        // 当前结束时间
        int time = 0;
        for (int[] meeting : meetings) {
            // 首先会议应该紧凑安排
            // 之前的任务完成时所需要的时间
            // meeting[0]>=time+10说明当前任务可以安排
            if (time + 10 <= meeting[0]) {
                // 收益入堆
                heap.offer(meeting[1]);
                time += 10;
            } else if (!heap.isEmpty() && heap.peek() < meeting[1]) {
                // 不能安排当前任务，但我们看看堆中有没有收益比当前小的，如果有我们可以选择不做这个任务，而做当前任务，即被替换的任务所需要的完成时间内被替换成了当前任务
                heap.poll();
                heap.offer(meeting[1]);
            }
        }
        // 统计堆中所有收益即为答案
        int ans = 0;
        while (!heap.isEmpty()) {
            ans += heap.poll();
        }
        return ans;
    }
    
}
```

---

> ***last change: 2023/4/23***

---
