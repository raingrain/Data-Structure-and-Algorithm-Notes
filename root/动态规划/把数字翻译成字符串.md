# 把数字翻译成字符串

## [剑指 Offer 46. 把数字翻译成字符串](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

> - ***Question***
>   - 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。
>   - 一个数字可能有多个翻译。
>   - 请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
>   - ***tips:***
>     - `0 <= num < 2^31`

---

## *Java*

> - ***暴力递归***
>   - 从左往右的尝试模型，思路见注释。

```java
class Solution {
    
    public int translateNum(int num) {
        return recursion(String.valueOf(num).toCharArray(), 0);
    }
    
    // 暴力递归，含义为假定[0-index]位置的情况我已经搞定了，求解str[index - len]上的数字能够组成字符串的方法数
    // 可变参数只有index，dp表是一维的
    public int recursion(char[] str, int index) {
        if (index == str.length) {
            // 这代表某条路径走完了，一种可以转换的方法被找到
            return 1;
        }
        // 如果题目是从1开始到26，0不能翻译的话，需要加上下面这个判断，此时我们认为前面的选择出错了
        /*if (str[index] == '0') {
            return 0;
        }*/
        // 首先我们认为每一个位置上的数字一定有单独转成一个字母的情况
        int ans = recursion(str, index + 1);
        // 当index后面还有下一个数字， 并且当前数字与下一个数字的组合不是‘03’形式（即当前数字不是0），且组成的两位数小于26时（因为题目说25是z），我们认为当前数字与下一个数字可以组成一个字母
        if (index + 1 < str.length && str[index] != '0' && (str[index] - '0') * 10 + (str[index + 1] - '0') <= 25) {
            // 直接跳到下下一个数字开始
            ans += recursion(str, index + 2);
        }
        return ans;
    }
    
}
```

> - ***动态规划***
>   - 时间复杂度为 `O(N)` ，额外空间复杂度为 `O(N)` ， `N` 为数字长度。

```java
class Solution {
    
    public int translateNum(int num) {
        return dp(String.valueOf(num).toCharArray());
    }
    
    public int dp(char[] str) {
        int len = str.length;
        // index的范围从0到str.length
        int[] dp = new int[len + 1];
        // 递归终止条件
        dp[len] = 1;
        // 从右往左填
        for (int index = len - 1; index >= 0; --index) {
            // 照抄
            dp[index] = dp[index + 1];
            if (index + 1 < str.length && str[index] != '0' && (str[index] - '0') * 10 + (str[index + 1] - '0') <= 25) {
                dp[index] += dp[index + 2];
            }
        }
        return dp[0];
    }
    
}
```

> - ***动态规划 + 滚动数组优化***
>   - 时间复杂度为 `O(N)` ，同时只用了 `cur, next, nextNext` 进行滚动更新，所以额外空间复杂度为 `O(1)` ， `N` 为数字长度。

```java
class Solution {
    
    public int translateNum(int num) {
        return dp(String.valueOf(num).toCharArray());
    }
    
    public int dp(char[] str) {
        int len = str.length;
        // 代表dp[index + 2]
        int nextNext = 0;
        // 代表dp[index + 1]
        int next = 1;
        // 代表dp[index]
        int cur = 1;
        // 从倒数第二个开始填，照抄上面的
        for (int index = len - 1; index >= 0; --index) {
            cur = next;
            if (index + 1 < str.length && str[index] != '0' && (str[index] - '0') * 10 + (str[index + 1] - '0') <= 25) {
                cur += nextNext;
            }
            nextNext = next;
            next = cur;
        }
        return cur;
    }
    
}
```

---

> ***last change: 2023/1/24***

---
