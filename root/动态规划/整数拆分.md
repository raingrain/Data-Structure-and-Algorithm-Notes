# 整数拆分

## 来源未知

> - ***Question 1***
>   - 给定一个正数 `n` ，返回将其拆分成一些数字的和的方法数。
>   - 要求每次拆下来的数不能比上一次拆下来的数小。
>   - 例如 `n = 4` ，有 `1 + 1 + 1 + 1, 1 + 1 + 2, 1 + 3, 0 + 4` 这四种拆分方法。

## [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

> - ***Question 2***
>   - 给定一个正整数 `n` ，将其拆分为 `k` 个正整数的和，并使这些整数的乘积最大化。
>   - 返回你可以获得的最大乘积。
>   - ***tips:***
>     - `k >= 2`
>     - `2 <= n <= 58`

---

## *Java*

> - ***Question 1: 暴力递归***
>   - 这个暴力递归的终止条件要思考一下。

```java
class Solution {
    
    // 递归含义，上一个拆出来的数是pre，还有数字rest要拆，后面拆的数都要大于pre，返回拆分方法数
    // 原始调用可以为recursion(1, n)
    // 假设我要拆5，我先认为要拆的是6，先拆了1，剩下的5有几种拆法
    // 写1保证了拆5时能试到1，写2就不行了
    public static int recursion(int pre, int rest) {
        // 你一直遵循着“每次选的数字都不会比上一次小”的原则，如果你能让rest变为0，说明这是一种对的选择
        if (rest == 0) {
            return 1;
        }
        // 你pre都大于rest了，你拆分能选的最大也就rest，而rest<pre
        // 我后面的选择必定违背“每次选的数字都不会比上一次小”的原则，所以前面的选择是不合法的选择
        if (pre > rest) {
            return 0;
        }
        int ans = 0;
        // 每一次的拆分选择都不会小于pre，即都不会比左边的数小
        // 每一次的拆分选择都不会大于rest
        for (int num = pre; num <= rest; ++num) {
            // num==rest返回1
            ans += recursion(num, rest - num);
        }
        return ans;
    }
    
}
```

> - ***Question 1: 动态规划***

```java
class Solution {
    
    public static int dp(int n) {
        // 一些判断条件
        if (n < 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        // 行从1开始，为了方便我们创建的dp表包含第0行，但我么不需要管它
        int[][] dp = new int[n + 1][n + 1];
        for (int i = 1; i < n + 1; ++i) {
            dp[i][0] = 1;
            // 我们容易看出，当pre==rest时，结果只有一种，那就是不拆rest
            dp[i][i] = 1;
        }
        for (int pre = n - 1; pre >= 1; --pre) {
            for (int rest = pre + 1; rest < n + 1; ++rest) {
                int ans = 0;
                for (int num = pre; num <= rest; ++num) {
                    ans += dp[num][rest - num];
                }
                dp[pre][rest] = ans;
            }
        }
        return dp[1][n];
    }
    
}
```

> - ***Question 1: 动态规划 + 斜率优化***
>   - 本题的空间位置的依赖是斜向的，我们用左边的+下边的值即可。

```java
class Solution {
    
    public static int dp(int n) {
        if (n < 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        // 行从1开始，为了方便我们创建的dp表包含第0行，但我么不需要管它
        int[][] dp = new int[n + 1][n + 1];
        for (int i = 1; i < n + 1; ++i) {
            dp[i][0] = 1;
            dp[i][i] = 1;
        }
        for (int pre = n - 1; pre >= 1; --pre) {
            for (int rest = pre + 1; rest < n + 1; ++rest) {
                // 通过观察表的空间位置依赖关系
                // 发现我依赖我左边rest-pre（即递归中第一次for循环num为pre时的rest被拆分成的另外一个数字rest-pre）位置及其左下角的值
                // 这个左下角经过观察可以用我下一行的数来替代
                // 这个表填的只是右上部分，则rest-pre一定大于0
                dp[pre][rest] = dp[pre + 1][rest] + dp[pre][rest - pre];
            }
        }
        return dp[1][n];
    }
    
}
```

> - ***Question 2: 暴力递归***
>   - 我们认为 `0` 和 `1` 不可以再被拆分。
>   - 对于一个大于等于 `2` 的数字 `num` ，我们可以把它拆成 `i` 和 `num - i` ， `i` 大于等于 `1` 但小于 `num` ，对于每一个选定的 `i` ，我们有两种选择：
>     - 不拆分 `num - i` 。
>     - 继续拆分 `num - i` 。
>   - 先对每一个i对应的这两种情况求最大值，再求所有i对应情况的最大值。

```java
class Solution {
    
    public int integerBreak(int n) {
        return recursion(n);
    }
    
    public int recursion(int num) {
        if (num == 0 || num == 1) {
            return 0;
        }
        int ans = Integer.MIN_VALUE;
        // 这里可以小于等于num/2，因为一个数拆成两个正整数之和会有重复的
        for (int i = 1; i < num; ++i) {
            // 不拆分
            int p1 = i * (num - i);
            // 继续拆分
            // num拆分为1 + (num - 1)时，p1已经考虑了
            int p2 = i * recursion(num - i);
            ans = Math.max(ans, Math.max(p1, p2));
        }
        return ans;
    }
    
}
```

> - ***Question 2: 动态规划***

```java
class Solution {
    
    public int integerBreak(int n) {
        return dp(n);
    }
    
    public int dp(int n) {
        int[] dp = new int[n + 1];
        for (int num = 1; num < n + 1; ++num) {
            int ans = Integer.MIN_VALUE;
            for (int i = 1; i < num; ++i) {
                int p1 = i * (num - i);
                int p2 = i * dp[num - i];
                ans = Math.max(ans, Math.max(p1, p2));
            }
            dp[num] = ans;
        }
        return dp[n];
    }
    
}
```

> - ***Question 2: 数学结论***
>   - 当 `n` 小于等于 `3` 时，返回 `n - 1` 。
>   - 当 `n` 大于 `3` 时，根据 `n` 除以 `3` 的余数进行分类讨论：
>     - 余数为 `0` ， `n` 拆成 `m (m >= 2)` 个 `3` 。
>     - 余数为 `1` ， `n` 拆成 `m - 1 (m >= 1)` 个 `3` 和 `2` 个 `2` 。
>     - 余数为 `2` ， `n` 拆成 `m (m >= 1) 个 3` 和 `1` 个 `2` 。

```java
class Solution {

    public int integerBreak(int n) {
        if (n <= 3) {
            return n - 1;
        }
        int quotient = n / 3;
        int remainder = n % 3;
        if (remainder == 0) {
            return (int) Math.pow(3, quotient);
        } else if (remainder == 1) {
            return (int) Math.pow(3, quotient - 1) * 4;
        } else {
            return (int) Math.pow(3, quotient) * 2;
        }
    }

}
```

---

> ***last change: 2023/1/28***

---
