# 树上差分

## 点差分

使用树上倍增或者Tarjan算法，可以快速查询每条路径两端点的最低公共祖先，假设 `x` 和 `y` 的最低公共祖先为 `lca` ，从 `x` 到 `y` 的路径上把所有点权都增加 `v` ，可以进行如下操作：

1. `num[x] += v`
2. `num[y] += v`
3. `num[lca] -= v`
4. `num[lca的父节点] -= v`

每次修改操作都这么操作，最后只需要按如下方式遍历树：

1. 当前来到节点 `u` ，DFS遍历 `u` 的所有子节点
2. 回溯时 `num[u] += num[u所有子节点]`

## 边差分

使用树上倍增或者Tarjan算法，可以快速查询每条路径两端点的最低公共祖先，假设 `x` 和 `y` 的最低公共祖先为 `lca` ，从 `x` 到 `y` 的路径上把所有边权都增加 `v` ，可以进行如下操作：

1. `num[x] += v`
2. `num[y] += v`
3. `num[lca] -= 2 * v`

每次修改操作都这么操作，最后只需要按如下方式遍历树：

1. 当前来到节点 `u` ，DFS遍历 `u` 的所有子节点
2. 遍历 `u` 的每条边，假设边 `e` 从父节点 `u` 连向子节点 `v` ，令 `weight[e] += num[v]`
3. 回溯时 `num[u] += num[u所有子节点]`
