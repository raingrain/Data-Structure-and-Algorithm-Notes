# 分发饼干

## [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

> - **Question**
>   - 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>   - 对每个孩子 `i` ，都有一个胃口值 `g[i]` ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j` ，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]` ，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>   - **Tips**
>     - `1 <= g.length <= 3 * 10^4`
>     - `0 <= s.length <= 3 * 10^4`
>     - `1 <= g[i], s[j] <= 2^31 - 1`

## Java

> - **贪心**
>   - 为了尽可能满足最多数量的孩子，从贪心的角度考虑，应该按照孩子的胃口从小到大的顺序依次满足每个孩子，且对于每个孩子，应该选择可以满足这个孩子的胃口且尺寸最小的饼干。
>   - 首先对数组 `g` 和 `s` 排序，然后从小到大遍历 `g` 中的每个元素，对于每个元素找到能满足该元素的 `s` 中的最小的元素。具体而言，令 `i` 是 `g` 的下标， `j` 是 `s` 的下标，初始时 `i` 和 `j` 都为 `0` ，进行如下操作。
>   - 对于每个元素 `g[i]` ，找到未被使用的最小的 `j` 使得 `g[i] <= s[j]` ，则 `s[j]` 可以满足 `g[i]` 。由于 `g` 和 `s` 已经排好序，因此整个过程只需要对数组 `g` 和 `s` 各遍历一次。当两个数组之一遍历结束时，说明所有的孩子都被分配到了饼干，或者所有的饼干都已经被分配或被尝试分配（可能有些饼干无法分配给任何孩子），此时被分配到饼干的孩子数量即为可以满足的最多数量。

```java
import java.util.Arrays;

class Solution {

    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int m = g.length, n = s.length;
        int count = 0;
        for (int i = 0, j = 0; i < m && j < n; i++, j++) {
            while (j < n && g[i] > s[j]) {
                j++;
            }
            if (j < n) {
                count++;
            }
        }
        return count;
    }

}
```
