# 让字符串成为回文串的最少插入次数和所有插入结果

## [1312. 让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

> - ***Question 1***
>   - 给你一个字符串 `s` ，每一次操作你都可以在字符串的任意位置插入任意字符。
>   - 请你返回让 `s` 成为回文串的最少操作次数。
>   - ***tips:***
>     - `1 <= s.length <= 500`
>     - `s` 中所有字符都是小写字母
> - ***Question 2***
>   - 返回 `Question 1` 中的一种插入情况。
> - ***Question 3***
>   - 返回 `Question 1` 中的所有插入情况。

---

## *Java*

> - ***Question 1: 动态规划***
>   - 样本对应模型。

```java
class Solution {
    
    public int minInsertions(String s) {
        char[] str = s.toCharArray();
        // dp[i][j]表示str[i...j]上的字符串变成回文最少需要添加几个字符
        int[][] dp = new int[str.length][str.length];
        // 因为left小于right，所以左下半区无效
        // 对于第一条对角线，一个字符自己和自己一定是回文，所以全为0
        for (int left = 0; left < str.length - 1; left++) {
            dp[left][left + 1] = str[left] == str[left + 1] ? 0 : 1;
        }
        for (int left = str.length - 3; left >= 0; left--) {
            for (int right = left + 2; right < str.length; right++) {
                // str[left...right]上的字符变成回文有三种可能性
                // 情况1：首先是str[left...right-1]变成回文，然后前面在加上一个str[right]
                // 情况2：首先是str[left+1...right]变成回文，然后后面在加上一个str[left]
                // 情况3：在str[left]等于str[right]的情况下，str[left+1...right-1]变成回文即可
                // 先看情况1和情况2
                dp[left][right] = Math.min(dp[left][right - 1], dp[left + 1][right]) + 1;
                // 有情况3再看一下情况3
                if (str[left] == str[right]) {
                    dp[left][right] = Math.min(dp[left][right], dp[left + 1][right - 1]);
                }
            }
        }
        return dp[0][str.length - 1];
    }
    
}
```

> - ***Question 2: 动态规划 + 回溯***

```java
class Solution {
    
    public String minInsertionsOneWay(String s) {
        char[] str = s.toCharArray();
        int[][] dp = new int[str.length][str.length];
        for (int left = 0; left < str.length - 1; left++) {
            dp[left][left + 1] = str[left] == str[left + 1] ? 0 : 1;
        }
        for (int left = str.length - 3; left >= 0; left--) {
            for (int right = left + 2; right < str.length; right++) {
                dp[left][right] = Math.min(dp[left][right - 1], dp[left + 1][right]) + 1;
                if (str[left] == str[right]) {
                    dp[left][right] = Math.min(dp[left][right], dp[left + 1][right - 1]);
                }
            }
        }
        // 以上为生成dp表的过程，下面开始回溯
        // dp表中回溯的位置
        int dpLeft = 0;
        int dpRight = str.length - 1;
        // 结果表需要几个字符，原字符长度+所需最少插入次数
        char[] ans = new char[str.length + dp[0][str.length - 1]];
        // 在结果表中填的位置
        int ansLeft = 0;
        int ansRight = ans.length - 1;
        // 保证不回溯到对角线以下
        while (dpLeft < dpRight) {
            // 随便回溯哪个都行
            if (dp[dpLeft][dpRight - 1] == dp[dpLeft][dpRight] - 1) {
                // 能往左回溯
                // 说明最后的字符串两端是由当前字符串遍历的最后一个位置填的
                ans[ansLeft] = str[dpRight];
                ans[ansRight] = str[dpRight];
                // 填完了收缩
                ansLeft++;
                ansRight--;
                // dp表中要来到正确的位置
                dpRight--;
            } else if (dp[dpLeft + 1][dpRight] == dp[dpLeft][dpRight] - 1) {
                ans[ansLeft] = str[dpLeft];
                ans[ansRight] = str[dpLeft];
                ansLeft++;
                ansRight--;
                dpLeft++;
            } else {
                ans[ansLeft] = str[dpLeft];
                ans[ansRight] = str[dpRight];
                ansLeft++;
                ansRight--;
                dpLeft++;
                dpRight--;
            }
        }
        // 还有一个位置没有填，如aba中的b
        if (dpLeft == dpRight) {
            // 填上
            ans[ansLeft] = str[dpLeft];
        }
        return String.valueOf(ans);
    }
    
}
```

> - ***Question 3: 动态规划 + 回溯***

```java
class Solution {
    
    public List<String> minInsertionsAllWays(String s) {
        char[] str = s.toCharArray();
        int[][] dp = new int[str.length][str.length];
        for (int left = 0; left < str.length - 1; left++) {
            dp[left][left + 1] = str[left] == str[left + 1] ? 0 : 1;
        }
        for (int left = str.length - 3; left >= 0; left--) {
            for (int right = left + 2; right < str.length; right++) {
                dp[left][right] = Math.min(dp[left][right - 1], dp[left + 1][right]) + 1;
                if (str[left] == str[right]) {
                    dp[left][right] = Math.min(dp[left][right], dp[left + 1][right - 1]);
                }
            }
        }
        char[] path = new char[str.length + dp[0][str.length - 1]];
        List<String> ans = new ArrayList<>();
        // 进回溯
        recursion(str, dp, 0, str.length - 1, path, 0, path.length - 1, ans);
        return ans;
    }
    
    // str是字符串
    // dp是dp表
    // dpLeft和dpRight是回溯dp的位置
    // path是一次的结果数组
    // pathLeft和pathRight是结果数组中填的位置
    // ans是所有结果存储的表
    // 最后将str[dpLeft][dpRight]填出path[pathLeft][pathRight]的结果加入ans
    private void recursion(char[] str, int[][] dp, int dpLeft, int dpRight, char[] path, int pathLeft, int pathRight, List<String> ans) {
        // base case
        if (dpLeft >= dpRight) {
            if (dpLeft == dpRight) {
                // 相等加
                path[pathLeft] = str[dpLeft];
            }
            ans.add(String.valueOf(path));
        }
        // 三种情况每种都玩一遍深度优先遍历，基本逻辑和选一个的很像
        if (dp[dpLeft][dpRight - 1] == dp[dpLeft][dpRight] - 1) {
            path[pathLeft] = str[dpRight];
            path[pathRight] = str[dpRight];
            recursion(str, dp, dpLeft, dpRight - 1, path, pathLeft + 1, pathRight - 1, ans);
        }
        if (dp[dpLeft + 1][dpRight] == dp[dpLeft][dpRight] - 1) {
            path[pathLeft] = str[dpLeft];
            path[pathRight] = str[dpLeft];
            recursion(str, dp, dpLeft + 1, dpRight, path, pathLeft + 1, pathRight - 1, ans);
        }
        if (str[dpLeft] == str[dpRight] && (dpLeft == dpRight - 1 || dp[dpLeft + 1][dpRight - 1] == dp[dpLeft][dpRight])) {
            path[pathLeft] = str[dpLeft];
            path[pathRight] = str[dpRight];
            recursion(str, dp, dpLeft + 1, dpRight - 1, path, pathLeft + 1, pathRight - 1, ans);
        }
    }
    
}
```

---

> ***last change: 2023/4/4***

---
