# 旅行商问题

## 左老师课堂讲述

> - ***Question***
>   - 有 `N` 个城市，任何两个城市之间都有距离，任何一座城市到自己的距离都为 `0` 。所有城市到城市之间的距离都保存在一张邻接矩阵中。现要找到一条环路径，使得旅行商从路径上的任意一座城市出发，必须经过所有城市且只经过一次，最后返回出发城市，总距离最短。

---

## *Java*

> - ***暴力递归***

```java
class Solution {
    
    public int TSP(int[][] matrix) {
        // set是一个数组，arr[i] = 1表示第i号城市还没有走过
        // arr[i] = null表示第i号城市走过了
        // 初始状态是全没走过
        List<Integer> set = new ArrayList<>();
        for (int i = 0; i < matrix.length; ++i) {
            set.add(1);
        }
        // 假设0号城市是出发点，也是环路径的终点
        return recursion(matrix, set, 0);
    }
    
    // 当前剩下的城市为set，出发城市start一定是set中没经历过的一个，请返回从出发城市到第一次递归调用时的城市的最短距离
    public int recursion(int[][] matrix, List<Integer> set, int start) {
        // 先获得当前集合中没走过的城市的数量
        int cityNum = 0;
        for (Integer integer : set) {
            if (integer != null) {
                ++cityNum;
            }
        }
        // 如果只剩一个城市没走，我们让它去终点即可
        if (cityNum == 1) {
            return matrix[start][0];
        }
        // 有多个城市，我们把出发城市设置成经过了
        set.set(start, null);
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < set.size(); ++i) {
            // 遍历所有能走的城市，所有不能走的城市都背置空了，包括出发城市
            if (set.get(i) != null) {
                // matrix[start][i]为出发城市到想去的城市的距离
                // recursion(matrix, set, i)想去的城市作为下一阶段的出发城市
                ans = Math.min(ans, matrix[start][i] + recursion(matrix, set, i));
            }
        }
        // 恢复现场
        set.set(start, 1);
        return ans;
    }
    
}
```

> - ***状态压缩 + 记忆化搜索***
>   - 观察到 `set` 是数组很难直接改动态规划，但它记录着城市的状态，每一个城市只有经历和没经历两种状态，直接用位图降维。

```java
class Solution {
    
    public int TSP(int[][] matrix) {
        // 假设有5个城市
        // 11111 表示5个城市都没有背经过
        // 那么从00000 ~ 11111 一共有1 << 6 100000种状态
        // 出发点一共有matrix.length种情况
        int[][] dp = new int[1 << matrix.length][matrix.length];
        for (int i = 0; i < dp.length; ++i) {
            for (int j = 0; j < dp[0].length; ++j) {
                // -1表示没算过
                dp[i][j] = -1;
            }
        }
        return recursion(matrix, dp, (1 << matrix.length) - 1, 0);
    }
    
    // 使用位图压缩城市的经过状态
    public int recursion(int[][] matrix, int[][] dp, int status, int start) {
        if (dp[status][start] != -1) {
            // 看看缓存表里面有没有
            return dp[status][start];
        }
        // 如果一个数等于自己最右侧的1，说明这个数的二进制只有1个1
        if (status == (status & (~status + 1))) {
            dp[status][start] = matrix[start][0];
        } else {
            // 其他位置与上1，不改变状态
            // 出发位置与上0，变成0
            status &= (~(1 << start));
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i < matrix.length; ++i) {
                // 其他位置与0变成0
                // 该位置如果为1，说明还没经过，与1变成1，经过了为0
                if ((status & (1 << i)) != 0) {
                    ans = Math.min(ans, matrix[start][i] + recursion(matrix, dp, status, i));
                }
            }
            // 其他位置或上0，不改变状态，出发位置或上1，变成1
            status |= (1 << start);
            dp[status][start] = ans;
        }
        // 记录后再返回
        return dp[status][start];
    }
    
}
```

---

> ***last change: 2023/2/3***

---
