# 抽牌游戏获胜的概率

## 谷歌面试加强版

> - ***Question***
>   - 面值为 `1 ~ N` 的牌组成一组，每次你从组里等概率的抽出 `1 ~ N` 中的一张下次抽会换一个新的组，有无限组。
>   - 当累加和 `< a` 时，你将一直抽牌。
>   - 当累加和 `>= a` 且 `< b` 时，你将获胜。
>   - 当累加和 `>= b` 时，你将失败。
>   - 请你返回获胜的概率，给定的参数为 `N, a, b` 。

---

## *Java*

> - ***动态规划 + 斜率优化***

```java
class Solution {
    
    public static double dp(int N, int a, int b) {
        // 清洗无效参数，a要小于b才行，两者都要大于0，要有牌
        if (N < 1 || a >= b || a < 0 || b < 0) {
            return 0.0;
        }
        // 必赢的区间长度大于牌数必赢
        // 因为你不管咋抽总有一次会抽进这个区间
        if (b - a >= N) {
            return 1.0;
        }
        // dp[i]表示从当前已经抽出的牌的累加和为i，继续抽牌赢的概率是多少
        double[] dp = new double[b];
        // 假设a=18，b=21，N=6
        // 那么18 19 20必赢，概率为1
        // 21及其往后都为0
        for (int i = a; i < b; i++) {
            dp[i] = 1.0;
        }
        // 17的概率为 18 + 19 + 20 = 1 * 3 / N
        if (a - 1 >= 0) {
            dp[a - 1] = 1.0 * (b - a) / N;
        }
        for (int cur = a - 2; cur >= 0; cur--) {
            // P16 = 17 + 18 + 19 + 20 = P17 + P17 * N
            // P15 = 16 + 17 + 18 + 19 + 20 = P16 + P16 * N
            // P14 = 15 + 16 + 17 + 18 + 19 + 20 = P15 + P15 * N
            // P13 = 14 + 15 + 16 + 17 + 18 + 19 = P14 + P14 * N
            double w = dp[cur + 1] + dp[cur + 1] * N;
            // P12 = 13 + 14 + 15 + 16 + 17 + 18 = P13 + P13 * N - P19
            // P11 = 12 + 13 + 14 + 15 + 16 + 17 = P12 + P12 * N - P18
            if (cur + 1 + N < b) {
                w -= dp[cur + 1 + N];
            }
            // 选取一张牌的概率为1/N
            dp[cur] = w / N;
        }
        // 初始累加和是0
        return dp[0];
    }
    
}
```
