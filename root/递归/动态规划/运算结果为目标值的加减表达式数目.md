# [494. 目标和](https://leetcode.cn/problems/target-sum/)

# [剑指 Offer II 102. 加减的目标值](https://leetcode.cn/problems/YaVDxD/)


> - ***Question***
>   - 给你一个整数数组 `nums` 和一个整数 `target`
>   - 向数组中的每个整数前添加 `+` 或 `-` ，然后串联起所有整数，可以构造一个表达式：
>     - 例如 `nums = [2, 1]` ，可以在 `2` 之前添加 `+` ，在 `1` 之前添加 `-` ，然后串联起来得到表达式 `+2-1` 
>   - 返回可以通过上述方法构造的且运算结果等于 `target` 的不同加减表达式的数目

---

### *Java*

> - ***暴力递归***
>   - 通过假设能够计算得出rest来进行尝试，具体细节看 `violenceRecursion` 
> - ***记忆化搜索***
>   - 在暴力递归中使用一张二维HashMap来存储计算结果，存储细节看参数定义
> - ***二维动态规划***
>   - 先进行4个优化：
>     - `nums` 中的数字的正负数与否不影响计算结果，因为你会随机加上 `+` 和 `-`
>     - 如果 `nums` 中的累加和全为 `sum` ，如果 `sum < target` ，即全取 `+` 还小于目标值，则返回 `0`
>     - `nums` 中的数字加减不会改变奇偶性，如果 `sum` 和 `target` 的奇偶性不同，则返回 `0`
>     - 设 `num` 中在前面添加 `+` 的数字集合为 `P` ，添加 `-` 的数字集合 `N` ，则有 `sum(P) - sum(N) = target` ，改造有 `sum(P) - sum(N) + sum(P) + sum(N) = target + sum(P) + sum(N)` ，即 `sum(P) = (target + sum) / 2` ，问题就转化为在 `nums` 中选择一些数字，使其累加和为 `(target + sum) / 2` 的不同选法有几种
>   - 动态规划的转移方程见 `subSetByDPBySpaceCompression()`
> - ***空间压缩的动态规划***
>   - 由于二维动态规划是严格位置依赖的，我们可以使用滚动数组来进行空间压缩，具体实现看 `subSetByDPBySpaceCompression()` 

```java
class Solution {
    
    public int findTargetSumWays(int[] nums, int target) {
        // return findTargetSumWaysByViolenceRecursion(nums, target);
        // return findTargetSumWaysByMemorySearch(nums, target);
        return findTargetSumWaysByDP(nums, target);
    }
    
    // 暴力递归
    public int findTargetSumWaysByViolenceRecursion(int[] nums, int target) {
        return violenceRecursion(nums, 0, target);
    }
    
    public int violenceRecursion(int[] nums, int index, int rest) {
        if (index == nums.length) {
            // 假定能凑出rest，如果最后减去结果不为0，则认为当前路径没法构成rest
            return rest == 0 ? 1 : 0;
        } else {
            // 前者为取+号
            // 后者为取-号
            return violenceRecursion(nums, index + 1, rest - nums[index]) + violenceRecursion(nums, index + 1, rest + nums[index]);
        }
    }
    
    // 记忆化搜索
    public int findTargetSumWaysByMemorySearch(int[] nums, int target) {
        return recursionByMemorySearch(nums, 0, target, new HashMap<Integer, HashMap<Integer, Integer>>());
    }
    
    // 采用HashMap套HashMap的结构来存储，一个index对应另外的一张表，该表主键为rest
    public int recursionByMemorySearch(int[] nums, int index, int rest, HashMap<Integer, HashMap<Integer, Integer>> map) {
        if (map.containsKey(index) && map.get(index).containsKey(rest)) {
            // 有键
            return map.get(index).get(rest);
        } else {
            int ans;
            if (index == nums.length) {
                // 假定能凑出rest，如果最后减去结果不为0，则认为当前路径没法构成rest
                
                ans = rest == 0 ? 1 : 0;
            } else {
                // 前者为取+号
                // 后者为取-号
                ans = recursionByMemorySearch(nums, index + 1, rest - nums[index], map) + recursionByMemorySearch(nums, index + 1, rest + nums[index], map);
            }
            // 没有这个index键，先建好
            if (!map.containsKey(index)) {
                map.put(index, new HashMap<Integer, Integer>());
            }
            map.get(index).put(rest, ans);
            return ans;
        }
    }
    
    // 经过大量优化的动态规划
    public int findTargetSumWaysByDP(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        // return sum < target || ((target & 1) ^ (sum & 1)) != 0 ? 0 : subSetByDP(nums, (target + sum) >> 1);
        return sum < target || ((target & 1) ^ (sum & 1)) != 0 ? 0 : subSetByDPBySpaceCompression(nums, (target + sum) >> 1);
    }
    
    // 二维的动态规划
    // 最终得出在nums中任意选择数字，选出的数字的累加和等于sum的不同选法有几种
    public int subSetByDP(int[] nums, int sum) {
        if (sum < 0) {
            return 0;
        } else {
            // dp[i][j]指在nums的前i个数字中自由选择数字，选择的数字的累加和为j的选法有几个
            int[][] dp = new int[nums.length + 1][sum + 1];
            // 不选，空集
            dp[0][0] = 1;
            // 第一行除了不选可以组成sum为0的情况，其他都不行，因为0行表示前0个即不选数字
            for (int i = 1; i <= nums.length; ++i) {
                for (int j = 0; j <= sum; ++j) {
                    // 不选当前数字，则结果为前i - 1个数中自由选择，选出累加和为j的选法有几种
                    dp[i][j] = dp[i - 1][j];
                    if (j - nums[i - 1] >= 0) {
                        // 如果当前需要的sum大于nums的第i个数字，那么我可以选它，选了它就要在前i - 1个数字中选择和为j - nums[i - 1]的选法
                        dp[i][j] += dp[i - 1][j - nums[i - 1]];
                    }
                }
            }
            return dp[nums.length][sum];
        }
    }
    
    // 空间压缩
    public int subSetByDPBySpaceCompression(int[] nums, int sum) {
        if (sum < 0) {
            return 0;
        } else {
            // 二维表的第一列已经建立好
            int[] dp = new int[sum + 1];
            dp[0] = 1;
            // 遍历index
            for (int num : nums) {
                // 首先原二维表中每个位置的值肯定依赖其上面一个位置的值
                // 其次我们从后面开始填，因为sum越大，能选择自己的选法就存在，直到某个位置时不能再选自己，结束循环
                for (int i = sum; i - num >= 0; --i) {
                    // 因为是从右往左填，则左边的是上一行的数据
                    dp[i] += dp[i - num];
                }
            }
            return dp[sum];
        }
    }
    
}
```

---

> ***last change: 2022/9/15***
