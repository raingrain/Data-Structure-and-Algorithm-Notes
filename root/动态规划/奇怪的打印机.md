# 奇怪的打印机

## [664. 奇怪的打印机](https://leetcode.cn/problems/strange-printer/)

> - ***Question***
>   - 有台奇怪的打印机有以下两个特殊要求：
>     - 打印机每次只能打印由同一个字符组成的序列。
>     - 每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。
>   - 给你一个字符串 `s` ，你的任务是计算这个打印机打印它需要的最少打印次数。
>   - ***tips:***
>     - `1 <= s.length <= 100`
>     - `s` 由小写英文字母组成

---

## *Java*

> - ***暴力递归***

```java
class Solution {
    
    public int strangePrinter(String s) {
        char[] str = s.toCharArray();
        return recursion(str, 0, str.length - 1);
    }
    
    // 递归含义：打印str[left~right]上的所有字符所需的最少次数
    // 潜台词，str[left]的字符一定先打
    public int recursion(char[] str, int left, int right) {
        // 1个字符打印一次
        if (left == right) {
            return 1;
        }
        // 如果每个字符都不同，最多打印区间长度次
        int ans = right - left + 1;
        // 分开左右两边打，最后合并
        for (int split = left + 1; split <= right; ++split) {
            // 但如果两边的首字符相同，我们可以合并，两边第一次都打第一个字符，次数-1
            ans = Math.min(ans, recursion(str, left, split - 1) + recursion(str, split, right) - (str[left] == str[split] ? 1 : 0));
        }
        return ans;
    }
    
}
```

> - ***动态规划***

```java
class Solution {
    
    public int strangePrinter(String s) {
        return dp(s.toCharArray());
    }
    
    public int dp(char[] str) {
        int[][] dp = new int[str.length][str.length];
        for (int i = 0; i < str.length; ++i) {
            dp[i][i] = 1;
        }
        for (int left = str.length - 2; left >= 0; --left) {
            for (int right = left + 1; right < str.length; ++right) {
                int ans = right - left + 1;
                for (int split = left + 1; split <= right; ++split) {
                    ans = Math.min(ans, dp[left][split - 1] + dp[split][right] - (str[left] == str[split] ? 1 : 0));
                }
                dp[left][right] = ans;
            }
        }
        return dp[0][str.length - 1];
    }
    
}
```

---

> ***last change: 2023/2/5***

---
