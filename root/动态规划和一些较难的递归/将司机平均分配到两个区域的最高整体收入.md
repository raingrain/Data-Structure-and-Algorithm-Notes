# 将司机平均分配到两个区域的最高整体收入

## 2020携程笔试

> - ***Question***
>   - 给定二维数组 `income` ， `income` 的行数表示司机数， `income[i]` 是一个二元组， `income[i][0]` 和 `income[i][1]` 分别是司机 `i` 去 `A` 地和 `B` 地工作所能获得的收入。
>   - 若要分配司机到 `A` 和 `B` 两地，要求两地分配的司机一样，请返回所有分配方法中能获得的最高整体收入。

---

## *Java*

> - ***记忆化搜索***

```java
class Solution {
    
    public int maxMoney(int[][] income) {
        if (income == null || income.length < 2 || (income.length & 1) != 0) {
            return 0;
        }
        int ARest = income.length / 2;
        int[][] dp = new int[income.length + 1][ARest + 1];
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                // 未计算
                dp[i][j] = -1;
            }
        }
        return recursion(income, 0, ARest, dp);
    }
    
    // 返回index号及其往后所有的司机，分配完且最终A和B区域的司机同样多的情况下，这些司机能分配出的总体最大收入是多少。
    // ARest是A区域还能分配的司机数
    public int recursion(int[][] income, int index, int ARest, int[][] dp) {
        if (dp[index][ARest] != -1) {
            return dp[index][ARest];
        }
        if (index == income.length) {
            // 司机分配完了，收入返回0
            dp[index][ARest] = 0;
        } else if (income.length - index == ARest) {
            // 如果剩下的未分配的司机人数等于A区域剩下的名额，说明B区域已经满了
            dp[index][ARest] = income[index][0] + recursion(income, index + 1, ARest - 1, dp);
        } else if (ARest == 0) {
            // A区域的名额已经满了，后续只能去B
            dp[index][ARest] = income[index][1] + recursion(income, index + 1, 0, dp);
        } else {
            // AB两个区域都没有满，当前司机分别尝试去A和去B，返回后续结果最大值
            int p1 = income[index][0] + recursion(income, index + 1, ARest - 1, dp);
            int p2 = income[index][1] + recursion(income, index + 1, ARest, dp);
            dp[index][ARest] = Math.max(p1, p2);
        }
        return dp[index][ARest];
    }
    
}
```

> - ***贪心***

```java
class Solution {
    
    public int maxMoney(int[][] income) {
        if (income == null || income.length < 2 || (income.length & 1) != 0) {
            return 0;
        }
        // arr[i]表示i号司机去B地服务的收入与去A地之间的差值
        int[] arr = new int[income.length];
        // 总和
        int sum = 0;
        for (int i = 0; i < income.length; i++) {
            arr[i] = income[i][1] - income[i][0];
            // 先假设全部司机都去A地
            sum += income[i][0];
        }
        // 找到去B地服役能获得更多收入和收入降低的最少的司机
        Arrays.sort(arr);
        for (int i = income.length - 1; i >= income.length / 2; i--) {
            // 加上它们的额外收入，可能有负值，但没办法，因为题目要求了去B地一般人，但经过排序以后负值也是较小的了
            sum += arr[i];
        }
        return sum;
    }
    
}
```

---

> ***last change: 2023/3/9***

---
