# 归并排序中隐含的位置关系

## 程序员代码面试指南：IT名企算法与数据结构题目最优解（第二版） 第8章 数组和矩阵问题 计算数组的小和

## [剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

## [315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

## [493. 翻转对](https://leetcode.cn/problems/reverse-pairs/)

## [2426. 满足不等式的数对数目](https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/)

## [327. 区间和的个数](https://leetcode.cn/problems/count-of-range-sum/)

> - ***Question 1***
>   - 给定一个数组，实现函数返回数组的小和（小和指对数组的每一个数来说，在它左边且严格小于它的数的和，每一个数的小和的总和就是数组的总和）。
> - ***Question 2***
>   - 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
>   - ***tips:***
>     - `0 <= 数组长度 <= 50000`
> - ***Question 333***
>   - 给你一个整数数组 `nums` ，按要求返回一个新数组 `counts` 。数组 `counts` 有该性质： `counts[i]` 的值是  `nums[i]` 右侧小于 `nums[i]` 的元素的数量。
>   - ***tips:***
>     - `1 <= nums.length <= 105`
>     - `-104 <= nums[i] <= 104`
> - ***Question 4***
>   - 给定一个数组 `nums` ，如果 `i < j` 且 `nums[i] > 2*nums[j]` 我们就将 `(i, j)` 称作一个重要翻转对。你需要返回给定数组中的重要翻转对的数量。
>   - ***tips:***
>     - 给定数组的长度不会超过 `50000`
>     - 输入数组中的所有数字都在 `32` 位整数的表示范围内
> - ***Question 5***
>   - 给你两个下标从 `0` 开始的整数数组 `nums1` 和 `nums2` ，两个数组的大小都为 `n` ，同时给你一个整数 `diff` ，统计满足以下条件的数对 `(i, j)` ： `0 <= i < j <= n - 1` 且 `nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff` ，请你返回满足条件的数对数目。
>   - ***tips:***
>     - `n == nums1.length == nums2.length`
>     - `2 <= n <= 105`
>     - `-104 <= nums1[i], nums2[i] <= 104`
>     - `-104 <= diff <= 104`
> - ***Question 6***
>   - 给你一个整数数组 `nums` 以及两个整数 `lower` 和 `upper` 。求数组中，值位于范围 `[lower, upper]` （包含 `lower` 和 `upper` ）之内的区间和的个数 。区间和 `S(i, j)` 表示在 `nums` 中，位置从 `i` 到 `j` 的元素之和，包含 `i` 和 `j (i <= j)`。
>   - ***tips:***
>     - `1 <= nums.length <= 105`
>     - `-231 <= nums[i] <= 231 - 1`
>     - `-105 <= lower <= upper <= 105`
>     - 题目数据保证答案是一个 `32` 位的整数

---

## *Java*

> - ***归并排序 + 索引数组 + 全局辅助数组优化 + 先处理信息再合并优化***
>   - 这几类题都是基于归并排序递归版的代码改进而来，增加的代码数量都来自于题目要求信息的处理，以及要求返回值会在递归和合并两个函数之间加上返回值。
>   - 核心思想在于基于合并过程中左右组各自的有序性以及隐含的左右组的元素在原数组中的相对位置不变两大特性求解结果。
>   - 求翻转对和区间和个数时要处理一下信息。
>   - 区间和个数这一题可以参考[区间和个数](../../有序表/根据题目改写SB树以实现有序表相关功能/区间和的个数.md)，本题除归并排序还可以用SB树改有序表解。
>   - 代码主要一个坑是用全局辅助数组和合并时新建数组时长度是不一样的，辅助数组的初始指针会是 `0` 或者 `left` ，还有就是位运算切记要括号。
>   - 可以先计算需要的结果再进行合并，而不是一边合并一边计算，这样代码不好看。
>   - 理解了逆序对的代码就可以理解后面的，这题本质上是求对于一个数来说，其左边的数有几个比它大，或者说右边的数有几个比它小，选择哪种思路决定了你在关键代码上的细节处理是怎么样的，这类题暴力搜索的时间复杂度一般是 `O(N^2)` ，用归并排序处理的话时间复杂度是 `O(N^logN)` ，空间复杂度为 `O(N)` ， `N` 为各类数组长度。

```java
class Solution {
    
    // 数组的小和
    public int smallerSum(int[] nums) {
        if (nums == null || nums.length < 2) {
            return 0;
        }
        return smallerSumByMergeSort(nums, 0, nums.length - 1);
    }
    
    // 归并排序
    private int smallerSumByMergeSort(int[] nums, int left, int right) {
        if (left == right) {
            return 0;
        }
        int mid = left + ((right - left) >> 1);
        return smallerSumByMergeSort(nums, left, mid) + smallerSumByMergeSort(nums, mid + 1, right) + mergeInSmallerSumByMergeSort(nums, left, mid, right);
    }
    
    // 归并过程
    private int mergeInSmallerSumByMergeSort(int[] nums, int left, int mid, int right) {
        int[] help = new int[right - left + 1];
        int point = 0;
        int leftPoint = left;
        int rightPoint = mid + 1;
        int ans = 0;
        while (leftPoint <= mid && rightPoint <= right) {
            ans += nums[leftPoint] < nums[rightPoint] ? nums[leftPoint] * (right - rightPoint + 1) : 0;
            help[point++] = nums[leftPoint] < nums[rightPoint] ? nums[leftPoint++] : nums[rightPoint++];
        }
        while (leftPoint <= mid) {
            help[point++] = nums[leftPoint++];
        }
        while (rightPoint <= right) {
            help[point++] = nums[rightPoint++];
        }
        System.arraycopy(help, 0, nums, left, help.length);
        /*for (int i = 0; i < help.length; ++i) {
            nums[left + i] = help[i];
        }*/
        return ans;
    }
    
    // 数组中的逆序对个数
    public int reversePairs(int[] nums) {
        if (nums == null || nums.length < 2) {
            return 0;
        } else if (nums.length == 2) {
            return nums[0] > nums[1] ? 1 : 0;
        } else {
            return reversePairsByMergeSort(nums, 0, nums.length - 1);
        }
    }
    
    // 归并排序
    private int reversePairsByMergeSort(int[] nums, int left, int right) {
        if (left == right) {
            return 0;
        }
        int mid = left + ((right - left) >> 1);
        return reversePairsByMergeSort(nums, left, mid) + reversePairsByMergeSort(nums, mid + 1, right) + mergeInReversePairsByMergeSortFromRightToLeft(nums, left, mid, right);
    }
    
    // 从左往右合并
    private int mergeInReversePairsByMergeSortFromLeftToRight(int[] nums, int left, int mid, int right) {
        int[] help = new int[right - left + 1];
        int point = 0;
        int leftPoint = left;
        int rightPoint = mid + 1;
        int ans = 0;
        while (leftPoint <= mid && rightPoint <= right) {
            // 找对于右边的数字来说，左边的数及其之后的有多少个比它大的
            // 那么在这个左子区域上的能够与当前这个右组数构成逆序对的个数就找到了，因为当前leftPoint比rightPoint大，而left到mid是有序的，自然leftPoint后面的数都能与当前rightPoint构成逆序对
            // 对于rightPoint来说，其左边的数的一小部分就被检查（检查能不能与之构成逆序对）完毕
            ans += nums[leftPoint] > nums[rightPoint] ? mid - leftPoint + 1 : 0;
            help[point++] = nums[leftPoint] <= nums[rightPoint] ? nums[leftPoint++] : nums[rightPoint++];
        }
        while (leftPoint <= mid) {
            help[point++] = nums[leftPoint++];
        }
        while (rightPoint <= right) {
            help[point++] = nums[rightPoint++];
        }
        System.arraycopy(help, 0, nums, left, help.length);
        /*for (int i = 0; i < help.length; ++i) {
            nums[left + i] = help[i];
        }*/
        return ans;
    }
    
    // 从右往左合并
    private int mergeInReversePairsByMergeSortFromRightToLeft(int[] nums, int left, int mid, int right) {
        int[] help = new int[right - left + 1];
        int point = help.length - 1;
        int leftPoint = mid;
        int rightPoint = right;
        int ans = 0;
        while (leftPoint >= left && rightPoint >= mid + 1) {
            ans += nums[leftPoint] > nums[rightPoint] ? rightPoint - mid : 0;
            help[point--] = nums[leftPoint] <= nums[rightPoint] ? nums[rightPoint--] : nums[leftPoint--];
        }
        while (leftPoint >= left) {
            help[point--] = nums[leftPoint--];
        }
        while (rightPoint >= mid + 1) {
            help[point--] = nums[rightPoint--];
        }
        System.arraycopy(help, 0, nums, left, help.length);
        /*for (int i = 0; i < help.length; ++i) {
            nums[left + i] = help[i];
        }*/
        return ans;
    }
    
    // 计算右侧小于当前元素的个数   
    // 这题难就难在它输出的也是原位置，之前的都是计数，不需要考虑位置，我只需要考虑左子区域上的所需情况即可，这时候我如果原始数组的位置改变，那么我处理存储结果到结果数组中就会非常麻烦
    // 我们采用索引数组+临时索引数组来做这个题
    // 索引数组顾名思义就是用来存储索引的，我们对原始数组排序就是更改值的位置，而我们对索引数组修改就是修改索引的位置，它存储的是排序后的数组的索引，你要arr[index[i]]才能获取实际的数字，然后temp是每次merge时用的查询用的index副本，改动的结果直接存到index中，避免每次交换都要拿一个temp值来存，代码太重复，只需要在开始时将所用的这段区间上的temp复制为index上的即可
    public List<Integer> countSmaller(int[] nums) {
        List<Integer> ans = new ArrayList<>();
        // 索引数组
        int[] index = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            index[i] = i;
        }
        // 结果数组
        int[] counts = new int[nums.length];
        // 全局缓存数组
        int[] temp = new int[nums.length];
        countSmallerByMergeSort(nums, 0, nums.length - 1, index, temp, counts);
        for (int i = 0; i < nums.length; i++) {
            ans.add(counts[i]);
        }
        return ans;
    }
    
    // 归并排序
    private void countSmallerByMergeSort(int[] nums, int left, int right, int[] index, int[] temp, int[] counts) {
        if (left == right) {
            return;
        }
        int mid = left + ((right - left) >> 1);
        countSmallerByMergeSort(nums, left, mid, index, temp, counts);
        countSmallerByMergeSort(nums, mid + 1, right, index, temp, counts);
        mergeInCountSmallerByMergeSort(nums, left, mid, right, index, temp, counts);
    }
    
    // 合并过程
    private void mergeInCountSmallerByMergeSort(int[] nums, int left, int mid, int right, int[] index, int[] temp, int[] counts) {
        if (right + 1 - left >= 0) {
            System.arraycopy(index, left, temp, left, right + 1 - left);
        }
        int point = left;
        int leftPoint = left;
        int rightPoint = mid + 1;
        while (leftPoint <= mid && rightPoint <= right) {
            // 索引数组的一大特点，只存索引，你需要双层调用，因为指针指向的数存的是索引
            // 等于的时候你如果移动了右边的话，假如右边还是一样的数，那你就没有办法通过(rightPoint - mid - 1)判断有几个小于当前左指针元素的数
            // 很显然这样写感觉很乱
            // 比是比原数组，修改索引
            if (nums[temp[leftPoint]] <= nums[temp[rightPoint]]) {
                // 这里是改，要在index上改
                index[point] = temp[leftPoint++];
                // 当前左组的数比右组之前的数都大
                // 这里是加结果，不属于递归，由于右部有序性，小于的都算
                counts[index[point++]] += (rightPoint - mid - 1);
            } else {
                index[point++] = temp[rightPoint++];
            }
        }
        // count[index[]]就是改对应的位置，index中存的是索引，调对应的就能与nums对应上
        while (leftPoint <= mid) {
            index[point] = temp[leftPoint++];
            counts[index[point++]] += (right - mid);
        }
        while (rightPoint <= right) {
            index[point++] = temp[rightPoint++];
        }
    }
    
    // 求逆序对的升级版翻转对的个数
    public int reversePairs(int[] nums) {
        if (nums == null || nums.length < 2) {
            return 0;
        } else if (nums.length == 2) {
            return nums[0] > nums[1] * 2 ? 1 : 0;
        } else {
            return reversePairsByMergeSort(nums, 0, nums.length - 1);
        }
    }
    
    // 归并排序
    private int reversePairsByMergeSort(int[] nums, int left, int right) {
        if (left == right) {
            return 0;
        }
        int mid = left + ((right - left) >> 1);
        return reversePairsByMergeSort(nums, left, mid) + reversePairsByMergeSort(nums, mid + 1, right) + mergeInReversePairsByMergeSort(nums, left, mid, right);
    }
    
    // 合并过程
    private int mergeInReversePairsByMergeSort(int[] nums, int left, int mid, int right) {
        int ans = 0;
        // 先处理信息
        // [mid + 1, windowR)
        for (int i = left, windowR = mid + 1; i <= mid; ++i) {
            // 内循环查找对于当前左组遍历到的那个数来说，右组有几个比它小
            while (windowR <= right && (long) nums[i] > (nums[windowR] * 2L)) {
                ++windowR;
            }
            // 窗口长度
            ans += windowR - (mid + 1);
        }
        // 再合并
        int[] help = new int[right - left + 1];
        int leftPoint = left;
        int rightPoint = mid + 1;
        int point = 0;
        while (leftPoint <= mid && rightPoint <= right) {
            help[point++] = nums[leftPoint] <= nums[rightPoint] ? nums[leftPoint++] : nums[rightPoint++];
        }
        while (leftPoint <= mid) {
            help[point++] = nums[leftPoint++];
        }
        while (rightPoint <= right) {
            help[point++] = nums[rightPoint++];
        }
        System.arraycopy(help, 0, nums, left, help.length);
        return ans;
    }
    
    // 满足不等式的数对数目
    // 化简等式
    // nums1[i] - nums1[j] <= nums2[i] - nums2[j] + diff => nums1[i] - nums2[i] <= nums1[j] - nums2[j] + diff => array[i] <= array[j] + diff
    // 问题转化为求array上满足array[i] <= array[j] + diff这一关系的数对即可，二维降到一维
    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {
        if (nums1 == null || nums2 == null || nums1.length < 2 || nums2.length < 2) {
            return 0;
        }
        if (nums1.length == 2) {
            return nums1[0] - nums1[1] <= nums2[0] - nums2[1] + diff ? 1 : 0;
        } else {
            int[] array = new int[nums1.length];
            int[] temp = new int[nums1.length];
            for (int i = 0; i < nums1.length; ++i) {
                array[i] = nums1[i] - nums2[i];
            }
            return numberOfPairsByMergeSort(0, nums1.length - 1, diff, array, temp);
        }
    }
    
    // 归并排序
    public long numberOfPairsByMergeSort(int left, int right, int diff, int[] array, int[] temp) {
        if (left == right) {
            return 0;
        }
        int mid = left + ((right - left) >> 1);
        return numberOfPairsByMergeSort(left, mid, diff, array, temp) + numberOfPairsByMergeSort(mid + 1, right, diff, array, temp) + mergeInNumberOfPairsByMergeSort(left, mid, right, diff, array, temp);
    }
    
    // 合并过程
    private long mergeInNumberOfPairsByMergeSort(int left, int mid, int right, int diff, int[] array, int[] temp) {
        long ans = 0;
        // 指针复用
        int leftPoint = left;
        int rightPoint = mid + 1;
        // 先处理信息
        while (rightPoint <= right) {
            // 内循环是为了找出对于当前遍历到的右组的那个数中，左组有几个数满足题目要求的不等式
            while (leftPoint <= mid && (array[leftPoint] <= array[rightPoint] + diff)) {
                ++leftPoint;
            }
            // 左组之前都小于当前遍历到的左组，自然小于右组
            ans += leftPoint - left;
            ++rightPoint;
        }
        // 合并
        leftPoint = left;
        rightPoint = mid + 1;
        int point = left;
        while (leftPoint <= mid && rightPoint <= right) {
            temp[point++] = array[leftPoint] <= array[rightPoint] ? array[leftPoint++] : array[rightPoint++];
        }
        while (leftPoint <= mid) {
            temp[point++] = array[leftPoint++];
        }
        while (rightPoint <= right) {
            temp[point++] = array[rightPoint++];
        }
        System.arraycopy(temp, left, array, left, right - left + 1);
        return ans;
    }
    
    // 求区间和个数
    public int countRangeSum(int[] nums, int lower, int upper) {
        return countRangeSumByMergeSort(nums, lower, upper);
    }

    // 归并排序前置工作
    public int countRangeSumByMergeSort(int[] nums, int lower, int upper) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        long[] preSum = new long[nums.length];
        getPreSum(nums, preSum);
        return process(preSum, 0, preSum.length - 1, lower, upper);
    }
    
    // 获取前缀和数组
    // nums[i-j] = preSum[j] - preSum[i - 1]
    // nums[0-j] = preSum[j]
    public void getPreSum(int[] nums, long[] preSum) {
        preSum[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            preSum[i] = preSum[i - 1] + nums[i];
        }
    }
    
    // 递归
    public int process(long[] preSum, int left, int right, int lower, int upper) {
        // 在遍历中并没有考虑到preSum[i - 1]不存在的情况，也就是nums[0-j]，下面的merge最长只能从nums[j]到nums[1-j]
        if (left == right) {
            return preSum[left] >= lower && preSum[left] <= upper ? 1 : 0;
        }
        int mid = left + ((right - left) >> 1);
        // 左右两区域中各自有多少个满足条件的加上大区域内有多少个，大区域又作为上一级的某一个左右区域被返回
        return process(preSum, left, mid, lower, upper) + process(preSum, mid + 1, right, lower, upper) + merge(preSum, left, mid, right, lower, upper);
    }
    
    // 合并
    public int merge(long[] arr, int left, int mid, int right, int lower, int upper) {
        int ans = 0;
        // 在左组上滑动的窗口区域
        // 对于当前的左区域，把每个右区域当j，看看其左边的这一块有几个符合条件的i
        // 设置两个左闭右开的区间值，从left开始
        // 由于归并排序导致的左右子区域的有序性进而导致的指针进动不回退性，区间在不断的往右进动，因为j对应的preSum[j]在增大，对应的preSum[i - 1]所成立的范围也在不断增大
        // 区间值碰到mid时是基本条件，arr[windowLeft]要保证大于等于min，arr[windowRight]要小于等于max，保证[arr[windowLeft], arr[windowRight]]是[min, max]的子集
        for (int i = mid + 1, windowLeft = left, windowRight = left; i <= right; i++) {
            long min = arr[i] - upper;
            long max = arr[i] - lower;
            while ((windowLeft <= mid) && (arr[windowLeft] < min)) {
                windowLeft++;
            }
            while ((windowRight <= mid) && (arr[windowRight] <= max)) {
                windowRight++;
            }
            ans += (windowRight - windowLeft);
        }
        
        // 一模一样，类型改成long而已
        long[] help = new long[right - left + 1];
        int leftPoint = left;
        int rightPoint = mid + 1;
        int point = 0;
        while ((leftPoint <= mid) && (rightPoint <= right)) {
            help[point++] = arr[leftPoint] < arr[rightPoint] ? arr[leftPoint++] : arr[rightPoint++];
        }
        while (leftPoint <= mid) {
            help[point++] = arr[leftPoint++];
        }
        while (rightPoint <= right) {
            help[point++] = arr[rightPoint++];
        }
        for (int i = 0; i < help.length; i++) {
            arr[left + i] = help[i];
        }
        return ans;
    }
    
}
```

---

> ***last change: 2022/11/2***

---
