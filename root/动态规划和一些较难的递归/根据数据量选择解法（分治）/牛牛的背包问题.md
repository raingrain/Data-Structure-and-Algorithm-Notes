# 牛牛的背包问题

## [牛牛的背包问题](https://www.nowcoder.com/questionTerminal/d94bb2fa461d42bcb4c0f2b94f5d4281)

> - ***Question***
>   - 牛牛准备参加学校组织的春游，出发前牛牛准备往背包里装入一些零食，牛牛的背包容量为 `w` 。
>   - 牛牛家里一共有 `n` 袋零食，第 `i` 袋零食体积为 `v[i]` 。
>   - 牛牛想知道在总体积不超过背包容量的情况下，他一共有多少种零食放法，总体积为 `0` 也算一种放法。
>   - ***输入描述***
>     - 输入包括两行：
>       - 第一行为两个正整数 `n` 和 `w(1 <= n <= 30, 1 <= w <= 2 * 10^9)` ，表示零食的数量和背包的容量。
>       - 第二行 `n` 个正整数 `v[i](0 <= v[i] <= 10^9)` ，表示每袋零食的体积。
>   - ***输出描述***
>     - 输出一个正整数，表示牛牛一共有多少种零食放法。

---

## *Java*

> - ***暴力递归***
>   - 最开始可能会有如下尝试， `dp[i][j]` 代表从 `weights[0 ~ i]` 范围上选择零食，体积严格等于 `j` 的情况数，对于每一个普遍位置，我们都有选当前零食和不选当前零食两种思路。但这种方法在题目的要求下不适合，我们发现动态规划表中的列会非常大。

```java
class Main {
    
    public int recursion(int[] weights, int index, int weight) {
        if (index == 0) {
            return weight == weights[index] ? 1 : 0;
        }
        return recursion(weights, index - 1, weight) + recursion(weights, index - 1, weight - weights[index]);
    }
    
}

```

> - ***分治 + 有序表***
>   - 左右分治各自求只在自己这个半区选择的话有多少种选择，然后再加上左右半区合并的逻辑即可。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Map;
import java.util.TreeMap;

public class Main {
    
    // 不管
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        while (in.nextToken() != StreamTokenizer.TT_EOF) {
            int n = (int) in.nval;
            in.nextToken();
            int bag = (int) in.nval;
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                in.nextToken();
                arr[i] = (int) in.nval;
            }
            long ways = ways(arr, bag);
            out.println(ways);
            out.flush();
        }
    }
    
    public static long ways(int[] weights, int bag) {
        if (weights == null || weights.length == 0) {
            return 0;
        }
        if (weights.length == 1) {
            return weights[0] <= bag ? 2 : 1;
        }
        int mid = (weights.length - 1) / 2;
        // 只选左半区
        TreeMap<Long, Long> leftMap = new TreeMap<>();
        long ways = recursion(weights, 0, mid, 0, bag, leftMap);
        // 只选右半区
        TreeMap<Long, Long> rightMap = new TreeMap<>();
        ways += recursion(weights, mid + 1, weights.length - 1, 0, bag, rightMap);
        // 右半区按照累加和进行排序，但存储的值是小于等于当前累加和的选法数
        TreeMap<Long, Long> rightMapPre = new TreeMap<>();
        long pre = 0;
        for (Map.Entry<Long, Long> entry : rightMap.entrySet()) {
            pre += entry.getValue();
            rightMapPre.put(entry.getKey(), pre);
        }
        // 计算即从左半区选，也从右半区选的方法数
        for (Map.Entry<Long, Long> entry : leftMap.entrySet()) {
            long leftWeight = entry.getKey();
            long leftWays = entry.getValue();
            // 左半区选择的累加和是严格确定的，那右半区的就要严格小于等于bag - leftWeight
            Long floor = rightMapPre.floorKey(bag - leftWeight);
            if (floor != null) {
                long rightWays = rightMapPre.get(floor);
                // 左半区的每一个选择都不同
                ways += leftWays * rightWays;
            }
        }
        // 补上所有零食都不带这一选择
        return ways + 1;
    }
    
    // weights 30
    // recursion(arr, 0, 14, 0, bag, map)
    // recursion(arr, 15, 29, 0, bag, map)
    // 从index出发，到end结束
    // 之前的选择，已经形成的累加和sum
    // 零食[index....end]自由选择，出来的所有累加和，不能超过bag，每一种累加和对应的方法数，填在map里
    // 最后不能什么货都没选
    // [3,3,3,3] bag = 6
    // 0 1 2 3
    // - - - - 0 -> （0 : 1）
    // - - - $ 3 -> （0 : 1）(3, 1)
    // - - $ - 3 -> （0 : 1）(3, 2)
    public static long recursion(int[] weights, int index, int end, long sum, long bag, TreeMap<Long, Long> map) {
        if (sum > bag) {
            // 违规
            return 0;
        }
        if (index > end) {
            // 选了
            if (sum != 0) {
                if (!map.containsKey(sum)) {
                    // 没有就在表里面加上去
                    map.put(sum, 1L);
                } else {
                    // 有就更新
                    map.put(sum, map.get(sum) + 1);
                }
                return 1;
            } else {
                // 所有货物都不选
                return 0;
            }
        }
        // 要 or 不要
        return recursion(weights, index + 1, end, sum, bag, map) + recursion(weights, index + 1, end, sum + weights[index], bag, map);
    }
    
}
```

---

> ***last change: 2023/1/31***

---
