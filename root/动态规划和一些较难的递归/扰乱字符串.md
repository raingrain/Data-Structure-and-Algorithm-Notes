# 扰乱字符串

## [87. 扰乱字符串](https://leetcode.cn/problems/scramble-string/)

> - ***Question 1***
>   - 使用下面描述的算法可以扰乱字符串 `s` 得到字符串 `t` ：
>     - 如果字符串的长度为 `1` ，算法停止。
>     - 如果字符串的长度 `> 1` ，执行下述步骤：
>       - 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 `s` ，则可以将其分成两个子字符串 `x` 和 `y` ，且满足 `s = x + y` 。
>       - 随机决定是要交换两个子字符串还是要保持这两个子字符串的顺序不变。即，在执行这一步骤之后， `s` 可能是 `s = x + y` 或者 `s = y + x` 。
>       - 在 `x` 和 `y` 这两个子字符串上继续从步骤 `1` 开始递归执行此算法。
>   - 给你两个长度相等的字符串 `s1` 和 `s2` ，判断 `s2` 是否是 `s1` 的扰乱字符串。如果是，返回 `true` ；否则，返回 `false` 。
>   - ***tips:***
>     - `s1.length == s2.length`
>     - `1 <= s1.length <= 30`
>     - `s1` 和 `s2` 由小写英文字母组成

---

## *Java*

> - ***记忆化搜索***

```java
class Solution {
    
    public boolean isScramble(String s1, String s2) {
        char[] str1 = s1.toCharArray();
        char[] str2 = s2.toCharArray();
        // 词频不一样直接false
        if (!isSameWordFrequency(str1, str2)) {
            return false;
        }
        // 记忆表，0为没计算，1为true，-1为false
        int[][][][] dp = new int[str1.length][str1.length][str2.length][str2.length];
        return recursion(str1, 0, str1.length - 1, str2, 0, str2.length - 1, dp);
    }
    
    // 返回str1[l1~r1]与str2[l2~r2]是不是互为扰乱字符串
    // 潜台词：r1 - l1 == r2 - l2
    private boolean recursion(char[] str1, int l1, int r1, char[] str2, int l2, int r2, int[][][][] dp) {
        if (dp[l1][r1][l2][r2] != 0) {
            return dp[l1][r1][l2][r2] == 1;
        }
        boolean ans = false;
        if (l1 == r1) {
            // 只剩下一个字符，相等就是旋变串
            ans = str1[l1] == str2[l2];
        } else {
            // 按照分割位置进行枚举
            // leftEnd表示分割后左区间尾
            for (int leftEnd = l1; leftEnd < r1; leftEnd++) {
                // str1的左对应str2的左
                // str1的右对应str2的右
                boolean p1 = recursion(str1, l1, leftEnd, str2, l2, l2 + leftEnd - l1, dp) && recursion(str1, leftEnd + 1, r1, str2, l2 + leftEnd - l1 + 1, r2, dp);
                // 只要有一个成立，立即跳出循环返回结果
                if (p1) {
                    ans = true;
                    break;
                }
                // 由于可以交换位置的关系
                // 也有str1的左对应str2的右
                // str1的右对应str2的左
                boolean p2 = recursion(str1, l1, leftEnd, str2, r2 - (leftEnd - l1), r2, dp) && recursion(str1, leftEnd + 1, r1, str2, l2, r2 - (leftEnd - l1) - 1, dp);
                if (p2) {
                    ans = true;
                    break;
                }
                
            }
        }
        dp[l1][r1][l2][r2] = ans ? 1 : -1;
        return ans;
    }
    
    // 给定两个数组，判断它们的词频表是否相同
    private boolean isSameWordFrequency(char[] str1, char[] str2) {
        /*if (str1.length != str2.length) {
            return false;
        }*/
        int[] map = new int[26];
        for (char c : str1) {
            map[c - 'a']++;
        }
        for (char c : str2) {
            if (--map[c - 'a'] < 0) {
                return false;
            }
        }
        return true;
    }
    
}
```

---

> ***last change: 2023/4/6***

---
