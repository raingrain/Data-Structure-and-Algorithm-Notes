# 删除字符串中的所有相邻重复项

## [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

## [1209. 删除字符串中的所有相邻重复项 II](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/)

> - ***Question 1***
>   - 给出由小写字母组成的字符串 `s` ，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
>   - 在 `s` 上反复执行重复项删除操作，直到无法继续删除。
>   - 在完成所有重复项删除操作后返回最终的字符串。
> - ***Question 2***
>   - 给你一个字符串 `s` ， `k` 倍重复项删除操作将会从 `s` 中选择 `k` 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。
>   - 你需要对 `s` 重复进行无限次这样的删除操作，直到无法继续为止。
>   - 在执行完所有删除操作后，返回最终得到的字符串。
> - ***tips:***
>   - `1 <= s.length <= 10^5`
>   - `2 <= k <= 10^4`
>   - `s` 中只含有小写英文字母
>   - 答案保证唯一

---

## *Java*

> - ***基于消消乐的思想用栈实现删除两个相邻且相等的元素***
>   - 我们只需要遍历该字符串，如果当前字符和栈顶字符相同，我们就将其消去，否则就将其入栈即可。最后将栈中元素转成字符串即可。
>   - 时间和空间复杂度 `O(n)` ，其中 `n` 是字符串的长度。

```java
class Solution {
    
    public String removeDuplicates(String s) {
        char[] str = s.toCharArray();
        char[] stack = new char[str.length];
        int peek = -1;
        for (char c : str) {
            if (peek == -1 || stack[peek] != c) {
                stack[++peek] = c;
            } else {
                --peek;
            }
        }
        return String.valueOf(stack, 0, peek + 1);
    }
    
}
```

> - ***一次遍历删除k个相邻且相等元素***
>   - 对重复的相邻字母计数，当计数达到 `k` 时将其删除。重复此操作，直到没有删除的字符为止。
>   - 初始长度为 `n` 的数组 `counts` 。遍历字符串：
>     - 如果当前字符与上一个字符相等，令 `counts[i] = counts[i - 1] + 1` 。如果加后 `counts[i] = k` ，删除这 `k` 个字符，令 `i = i - k` 。
>     - 否则，令 `counts[i] = 1` 。
>   - 时间和空间复杂度 `O(n)` ，其中 `n` 是字符串的长度。

```java
class Solution {
    
    public String removeDuplicates(String s, int k) {
        StringBuilder sb = new StringBuilder(s);
        int[] counts = new int[sb.length()];
        for (int i = 0; i < sb.length(); ++i) {
            if (i == 0 || sb.charAt(i) != sb.charAt(i - 1)) {
                // 和上一个字符不同
                // 可认为第一次出现
                counts[i] = 1;
            } else {
                // 被k个相同且相邻的字符隔开后的字符在这k个字符被删除后又会聚合在一起，不会因为隔开走上面的if
                counts[i] = counts[i - 1] + 1;
                if (counts[i] == k) {
                    sb.delete(i + 1 - k, i + 1);
                    i = i - k;
                }
            }
        }
        return sb.toString();
    }
    
}
```

---

> ***last change: 2022/11/30***

---
