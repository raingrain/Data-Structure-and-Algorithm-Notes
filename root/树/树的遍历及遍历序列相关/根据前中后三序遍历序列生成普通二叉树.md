# 根据前中后三序遍历序列生成普通二叉树

## [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

## [剑指 Offer 07. 重建二叉树](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/)

## [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

## [889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

> - ***Question 1***
>   - 给定两个整数数组 `preorder` 和 `inorder` ，其中 preorder 是二叉树的前序遍历， `inorder` 是同一棵树的中序遍历，请构造二叉树并返回其根节点
> - ***Question 2***
>   - 给定两个整数数组 `inorder` 和 `postorder` ，其中 inorder 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请构造二叉树并返回其根节点
> - ***Question 3***
>   - 给定两个整数数组 `preorder` 和 `postorder` ，其中 preorder 是二叉树的前序遍历， `postorder` 是同一棵树的后序遍历，请构造二叉树并返回其根节点
> - ***tips:***
>   - `1 <= inorder.length == preorder.length == postorder.length <= 3000`
>   - `-3000 <= preorder[i] and inorder[i] and postorder[i] <= 3000`
>   - `preorder` 、 `inorder` 和 `postorder` 均无重复元素
>   - 三个数组的内容相同，顺序不同
>   - `preorder` 保证为二叉树的前序遍历序列
>   - `inorder` 保证为二叉树的中序遍历序列
>   - `postorder` 保证为二叉树的后序遍历序列

---

## *Java*

> - ***递归***
>   - 对于先序与中序，中序与后序来说，我们通过先序/后序确定一颗树的根节点的值，然后建好根节点，然后在中序数组中查找根节点所在的索引（可以提前将（节点值-中序数组中的索引）这一键值对存入 `HashMap` 中，避免每次递归都要循环查找），计算出两种顺序的数组中左右子树的范围（中间节点索引知道了，根据传入的用于构建树的范围就可以计算出左右子树的索引范围），然后递归下去（把索引范围传下去，而不是传剪裁后的数组）进行构建，返回的结果挂在左右节点上，当子树的范围出现左边界大于右边界时返回空即可
> - ***迭代（难）***
>   - 根据前序与中序构造：
>     - 我们用一个栈（维护当前节点的所有还没有考虑过右儿子的祖先节点）和一个指针（当前节点不断往左走达到的最终节点）辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点，指针在中序遍历中移动
>     - 我们依次枚举前序遍历中除了第一个节点以外的每个节点，如果 `index` 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 `index` ，并将当前节点作为最后一个弹出的节点的右儿子（遇上右节点时处理之前入栈的节点，这一定与中序序列相对应）
>     - 如果 `index` 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子
>     - 无论是哪一种情况，我们最后都将当前的节点入栈
>   - 根据中序与后序构造：
>     - 上述两种加入情况的加入边调换，`index` 指向栈顶节点时往左加，反之右加
>     - 要遍历的数组是后序数组且从右往左，注意根节点的选取
>   - 根据前序与后序构造：
>     - 差不多的思路，看代码，以先序作为要遍历的数组，加入顺序和根据前序与中序构造相同，但如果 `index` 恰好指向栈顶节点，调整完后我们取栈顶元素和不是最后一个被弹出的元素做父节点
> - 时间复杂度与空间复杂度都是 `O(n)` ，其中 `n` 是树中的节点个数，除去返回的答案需要的 `O(n)` 空间之外，我们还需要使用 `O(n)` 的空间存储哈希映射，以及 `O(h)` （其中 `h` 是树的高度， `h < n` ）的空间表示递归时栈空间
> - ***补充***
>   - 对于二叉树中的一个节点 `x` ，其在先序遍历序列中的位置的左边部分的数字集合设为 `A` ，其在后序遍历序列中的位置的右边部分的数字集合设为 `B` ，则 `A` 交 `B` 的结果中的节点是且仅是 `x` 的祖先节点，证明：
>     - `x` 的所有祖先节点在先序遍历中一定出现在它的左边，在后序遍历中一定出现在它的右边
>     - `x` 的所有孩子节点一定不会出现在 `A` 或者 `B` 中，因为先序遍历中 `x` 的孩子一定在x的右边而后序遍历中一定在左边
>     - `x` 在左树姿态下的右兄弟节点在先序遍历中出现在其右边， `x` 在右树姿态下的左兄弟节点在后序遍历中出现在其左边

```java
class TreeNode {
    
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) {this.val = val;}
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
    
}

class Solution {
    
    public TreeNode buildTree(int[] array1, int[] array2) {
        return buildTreeByPreIn(array1, array2);
        // return buildTreeByInPost(array1, array2);
    }
    
    // 根据前序和中序构造
    public TreeNode buildTreeByPreIn(int[] preorder, int[] inorder) {
        return buildTreeByPreInByIteration(preorder, inorder);
        /*HashMap<Integer, Integer> valueInInorder = new HashMap<>();
        for (int i = 0; i < inorder.length; ++i) {
            valueInInorder.put(inorder[i], i);
        }
        return buildTreeByPreInByRecursion(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1, valueInInorder);*/
    }
    
    // 递归
    public TreeNode buildTreeByPreInByRecursion(int[] preorder, int[] inorder, int preorderStart, int preorderEnd, int inorderStart, int inorderEnd, HashMap<Integer, Integer> valueInInorder) {
        if (preorderStart > preorderEnd || inorderStart > inorderEnd) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[preorderStart]);
        int rootIndexInInorder = valueInInorder.get(preorder[preorderStart]);
        int leftTreeSize = rootIndexInInorder - inorderStart;
        root.left = buildTreeByPreInByRecursion(preorder, inorder, preorderStart + 1, preorderStart + leftTreeSize, inorderStart, rootIndexInInorder - 1, valueInInorder);
        root.right = buildTreeByPreInByRecursion(preorder, inorder, preorderStart + 1 + leftTreeSize, preorderEnd, rootIndexInInorder + 1, inorderEnd, valueInInorder);
        return root;
    }
    
    // 迭代
    public TreeNode buildTreeByPreInByIteration(int[] preorder, int[] inorder) {
        if (preorder == null || preorder.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[0]);
        Deque<TreeNode> stack = new ArrayDeque<>();
        stack.push(root);
        int inorderIndex = 0;
        for (int i = 1; i < preorder.length; ++i) {
            TreeNode node = stack.peek();
            if (node.val != inorder[inorderIndex]) {
                node.left = new TreeNode(preorder[i]);
                stack.push(node.left);
            } else {
                while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {
                    node = stack.pop();
                    ++inorderIndex;
                }
                node.right = new TreeNode(preorder[i]);
                stack.push(node.right);
            }
        }
        return root;
    }
    
    // 根据中序与后序构造
    public TreeNode buildTreeByInPost(int[] inorder, int[] postorder) {
        return buildTreeByInPostByIteration(inorder, postorder);
        /*HashMap<Integer, Integer> valueInInorder = new HashMap<>();
        for (int i = 0; i < inorder.length; ++i) {
            valueInInorder.put(inorder[i], i);
        }
        return buildTreeByInPostByRecursion(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1, valueInInorder);*/
    }
    
    // 递归
    public TreeNode buildTreeByInPostByRecursion(int[] inorder, int[] postorder, int inorderStart, int inorderEnd, int postorderStart, int postorderEnd, HashMap<Integer, Integer> valueInInorder) {
        if (inorderStart < inorderEnd || postorderStart < postorderEnd) {
            return null;
        }
        TreeNode root = new TreeNode(postorder[postorderEnd]);
        int rootIndexInInorder = valueInInorder.get(postorder[postorderEnd]);
        root.left = buildTreeByInPostByRecursion(inorder, postorder, inorderStart, rootIndexInInorder - 1, postorderStart, postorderStart + (rootIndexInInorder - inorderStart) - 1, valueInInorder);
        root.right = buildTreeByInPostByRecursion(inorder, postorder, rootIndexInInorder + 1, inorderEnd, postorderStart + (rootIndexInInorder - inorderStart), postorderEnd - 1, valueInInorder);
        return root;
    }
    
    // 迭代
    public TreeNode buildTreeByInPostByIteration(int[] inorder, int[] postorder) {
        if (postorder == null || postorder.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(postorder[postorder.length - 1]);
        Deque<TreeNode> stack = new ArrayDeque<>();
        stack.push(root);
        int inorderIndex = inorder.length - 1;
        for (int i = postorder.length - 2; i >= 0; --i) {
            TreeNode node = stack.peek();
            if (node.val != inorder[inorderIndex]) {
                node.right = new TreeNode(postorder[i]);
                stack.push(node.right);
            } else {
                while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {
                    node = stack.pop();
                    --inorderIndex;
                }
                node.left = new TreeNode(postorder[i]);
                stack.push(node.left);
            }
        }
        return root;
    }
    
    // 根据前序与后序构造
    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        return constructFromPrePostByIteration(preorder, postorder);
        // return constructFromPrePostByRecursion(preorder, postorder, 0, 0, preorder.length);
    }
    
    // 递归
    public TreeNode constructFromPrePostByRecursion(int[] preorder, int[] postorder, int i0, int i1, int treeSize) {
        if (treeSize == 0) {
            return null;
        } else if (treeSize == 1) {
            return new TreeNode(preorder[i0]);
        } else {
            int leftTreeSize = 1;
            for (; leftTreeSize < treeSize; ++leftTreeSize) {
                if (postorder[i1 + leftTreeSize - 1] == preorder[i0 + 1]) {
                    break;
                }
            }
            TreeNode root = new TreeNode(preorder[i0]);
            root.left = constructFromPrePostByRecursion(preorder, postorder, i0 + 1, i1, leftTreeSize);
            root.right = constructFromPrePostByRecursion(preorder, postorder, i0 + 1 + leftTreeSize, i1 + leftTreeSize, treeSize - 1 - leftTreeSize);
            return root;
        }
    }
    
    // 迭代
    public TreeNode constructFromPrePostByIteration(int[] preorder, int[] postorder) {
        TreeNode root = new TreeNode(preorder[0]);
        Deque<TreeNode> stack = new ArrayDeque<>();
        stack.push(root);
        int postorderIndex = 0;
        
        for (int i = 1; i < preorder.length; i++) {
            TreeNode node = stack.peek();
            if (node.val != postorder[postorderIndex]) {
                node.left = new TreeNode(preorder[i]);
                stack.push(node.left);
            } else {
                while (!stack.isEmpty() && stack.peek().val == postorder[postorderIndex]) {
                    node = stack.pop();
                    postorderIndex++;
                }
                node = stack.peek();
                node.right = new TreeNode(preorder[i]);
                stack.push(node.right);
            }
        }
        return root;
    }
    
}
```

---

> ***last change: 2022/10/23***

---
