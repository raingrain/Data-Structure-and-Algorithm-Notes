# 最长递增子序列

## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

> - ***Question 1***
>   - 给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。
>   - 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如 `[3, 6, 2, 7]` 是数组 `[0, 3, 1, 6, 2, 2, 7]` 的子序列。
>   - ***tips:***
>     - `1 <= nums.length <= 2500`
>     - `-10^4 <= nums[i] <= 10^4`

## [334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/)

> - ***Question 2***
>   - 给你一个整数数组 `nums` ，判断这个数组中是否存在长度为 `3` 的递增子序列。
>   - 如果存在这样的三元组下标 `(i, j, k)` 且满足 `i < j < k` ，使得 `nums[i] < nums[j] < nums[k]` ，返回 `true` ；否则，返回 `false` 。
>   - ***tips:***
>     - `1 <= nums.length <= 5 * 10^5`
>     - `-2^31 <= nums[i] <= 2^31 - 1`

## [354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)

> - ***Question 3***
>   - 给你一个二维整数数组 `envelopes` ，其中 `envelopes[i] = [wi, hi]` ，表示第 i` 个信封的宽度和高度。
>   - 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。
>   - 请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。
>   - 注意不允许旋转信封。
>   - ***tips:***
>     - `1 <= envelopes.length <= 10^5`
>     - `envelopes[i].length == 2`
>     - `1 <= wi, hi <= 10^5`

---

## *Java*

> - ***Question 1: 动态规划***
>   - 定义 `dp[i]` 为考虑前 `i` 个元素，以第 `i` 个数字结尾的最长上升子序列的长度，注意 `nums[i]` 必须被选取。
>   - 我们从小到大计算 `dp` 数组的值，在计算 `dp[i]` 之前，我们已经计算出 `dp[0 ~ i−1]` 的值，则状态转移方程为 `dp[i] = max(dp[i], dp[j] + 1)` ，其中 `0 <= j < i` 且 `num[j] < num[i]` 。
>   - 即考虑往 `dp[0 ~ i−1]` 中最长的上升子序列后面再加一个 `nums[i]` 。由于 `dp[j]` 代表 `nums[0 ~ j]` 中以 `nums[j]` 结尾的最长上升子序列，所以如果能从 `dp[j]` 这个状态转移过来，那么 `nums[i]` 必然要大于 `nums[j]` ，才能将 `nums[i]` 放在 `nums[j]` 后面以形成更长的上升子序列。
>   - 最后，整个数组的最长上升子序列即所有 `dp[i]` 中的最大值。

```java
class Solution {
    
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int ans = 1;
        for (int i = 1; i < nums.length; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
    
}
```

> - ***Question 1 & Question 2: 贪心 + 二分查找***
>   - 多玩一个新的数组。
>   - `Question 2` 的题意就是最长递增子序列的长度有没有大于等于 `3` 。

```java
class Solution {

    public boolean increasingTriplet(int[] nums) {
        return lengthOfLIS(nums) >= 3;
    }
    
    public int lengthOfLIS(int[] nums) {
        /*if (nums == null || nums.length == 0) {
            return 0;
        }*/
        // ends数组
        // ends[i]表示 : 目前所有长度为i+1的递增子序列的最小结尾
        int[] ends = new int[nums.length];
        // 根据含义, 一开始ends[0] = nums[0]
        ends[0] = nums[0];
        // ends有效区范围是0...right，right往右为无效区
        // 所以一开始right = 0, 表示有效区只有0...0范围
        int right = 0;
        // 最长递增子序列的长度
        // 全局变量，抓取每一步的答案，取最大的结果
        int max = 1;
        for (int i = 1; i < nums.length; i++) {
            int l = 0;
            int r = right;
            // 在ends[l...r]范围上二分
            // 如果 当前数(nums[i]) > ends[m]，砍掉左侧
            // 如果 当前数(nums[i]) <= ends[m]，砍掉右侧
            // 整个二分就是在ends里寻找 >= 当前数(nums[i])的最左位置
            // 就是从while里面出来时，l所在的位置。
            // 如果ends中不存在 >= 当前数(nums[i])的情况，将返回有效区的越界位置
            // 也就是从while里面出来时，l所在的位置，是有效区的越界位置
            // 比如 : ends = { 3, 5, 9, 12, 再往右无效}
            // 如果当前数为8, 从while里面出来时，l将来到2位置
            // 比如 : ends = { 3, 5, 9, 12, 再往右无效}
            // 如果当前数为13, 从while里面出来时，l将来到有效区的越界位置，4位置
            while (l <= r) {
                int m = (l + r) / 2;
                if (nums[i] > ends[m]) {
                    l = m + 1;
                } else {
                    r = m - 1;
                }
            }
            // 从while里面出来，看l的位置
            // 如果l比right大，说明扩充了有效区，那么right变量要随之变大
            // 如果l不比right大，说明l没有来到有效区的越界位置，right不变
            right = Math.max(right, l);
            // l的位置，就是当前数应该填到ends数组里的位置
            ends[l] = nums[i];
            // 更新全局变量
            max = Math.max(max, l + 1);
        }
        return max;
    }
    
}
```

> - ***Question 3***
>   - 二维最长递增子序列问题，先将信封数组按照宽度由小到大，宽度相同长度由大到小排序。排序后提取出高度数组，对于这一个高度数组，同长度的但高度比我小的已经在我后面了，不会干扰我的选择，而一个普遍位置的信封的左边必然是宽度相同高度比它大或宽度比它小高度未知的数字，对这个提取出来的高度数组做一维最长递增子序列求解即可。

```java
class Solution {
    
    public int maxEnvelopes(int[][] envelops) {
        Envelope[] arr = sort(envelops);
        int[] ends = new int[envelops.length];
        ends[0] = arr[0].height;
        int right = 0;
        for (int i = 1; i < arr.length; i++) {
            int l = 0;
            int r = right;
            while (l <= r) {
                int m = (l + r) / 2;
                if (arr[i].height > ends[m]) {
                    l = m + 1;
                } else {
                    r = m - 1;
                }
            }
            right = Math.max(right, l);
            ends[l] = arr[i].height;
        }
        return right + 1;
    }
    
    public static class Envelope {
        
        public int weight;
        public int height;
        
        public Envelope(int weight, int height) {
            this.weight = weight;
            this.height = height;
        }
        
    }
    
    public static Envelope[] sort(int[][] envelops) {
        Envelope[] ans = new Envelope[envelops.length];
        for (int i = 0; i < envelops.length; i++) {
            ans[i] = new Envelope(envelops[i][0], envelops[i][1]);
        }
        Arrays.sort(ans, (o1, o2) -> o1.weight != o2.weight ? o1.weight - o2.weight : o2.height - o1.height);
        return ans;
    }
    
}
```

---

> ***last change: 2023/4/18***

---
