# 最长递增子序列

## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

> - ***Question 1***
>   - 给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。
>   - 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如 `[3, 6, 2, 7]` 是数组 `[0, 3, 1, 6, 2, 2, 7]` 的子序列。
>   - ***tips:***
>     - `1 <= nums.length <= 2500`
>     - `-10^4 <= nums[i] <= 10^4`

## [2111. 使数组 K 递增的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/)

> - ***Question 2***
>   - 给你一个下标从 `0` 开始包含 `n` 个正整数的数组 `arr` ，和一个正整数 `k` 。如果对于每个满足 `k <= i <= n - 1` 的下标 `i` ，都有 `arr[i - k] <= arr[i]` ，那么我们称 `arr` 是 `K` 递增的。
>   - 每一次操作中，你可以选择一个下标 `i` 并将 `arr[i]` 改成任意正整数。请你返回对于给定的 `k` ，使数组变成 `K` 递增的最少操作次数。
>   - ***tips:***
>     - `1 <= arr.length <= 10^5`
>     - `1 <= arr[i], k <= arr.length`

## [334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/)

> - ***Question 3***
>   - 给你一个整数数组 `nums` ，判断这个数组中是否存在长度为 `3` 的递增子序列。
>   - 如果存在这样的三元组下标 `(i, j, k)` 且满足 `i < j < k` ，使得 `nums[i] < nums[j] < nums[k]` ，返回 `true` ；否则，返回 `false` 。
>   - ***tips:***
>     - `1 <= nums.length <= 5 * 10^5`
>     - `-2^31 <= nums[i] <= 2^31 - 1`

## [354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)

> - ***Question 4***
>   - 给你一个二维整数数组 `envelopes` ，其中 `envelopes[i] = [wi, hi]` ，表示第 i` 个信封的宽度和高度。
>   - 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。
>   - 请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。
>   - 注意不允许旋转信封。
>   - ***tips:***
>     - `1 <= envelopes.length <= 10^5`
>     - `envelopes[i].length == 2`
>     - `1 <= wi, hi <= 10^5`

## [673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)

> - ***Question 5***
>   - 给定一个未排序的整数数组 `nums` ，返回最长递增子序列的个数 。
>   - 注意这个数列必须是严格递增的。
>   - ***tips:***
>     - `1 <= nums.length <= 2000`
>     - `-10^6 <= nums[i] <= 10^6`

## 微众银行

> - ***Question 6***
>   - 给定一个数字 `n` ，代表数组的长度。
>   - 给定一个数字 `m` ，代表数组每个位置都可以在 `1 ~ m` 之间选择数字，所有长度为 `n` 的数组中，最长递增子序列长度为 `3` 的数组，叫做达标数组，返回达标数组的数量
>   - ***tips:***
>     - `1 <= n <= 500`
>     - `1 <= m <= 10`

---

## *Java*

> - ***Question 1: 动态规划***
>   - 定义 `dp[i]` 为考虑前 `i` 个元素，以第 `i` 个数字结尾的最长上升子序列的长度，注意 `nums[i]` 必须被选取。
>   - 我们从小到大计算 `dp` 数组的值，在计算 `dp[i]` 之前，我们已经计算出 `dp[0 ~ i−1]` 的值，则状态转移方程为 `dp[i] = max(dp[j]) + 1` ，其中 `0 <= j < i` 且 `num[j] < num[i]` 。
>   - 即考虑往 `dp[0 ~ i−1]` 中最长的上升子序列后面再加一个 `nums[i]` 。由于 `dp[j]` 代表 `nums[0 ~ j]` 中以 `nums[j]` 结尾的最长上升子序列，所以如果能从 `dp[j]` 这个状态转移过来，那么 `nums[i]` 必然要大于 `nums[j]` ，才能将 `nums[i]` 放在 `nums[j]` 后面以形成更长的上升子序列。
>   - 最后，整个数组的最长上升子序列即所有 `dp[i]` 中的最大值。

```java
class Solution {
    
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int ans = 1;
        for (int i = 1; i < nums.length; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
    
}
```

> - ***Question 1 & Question 3: 贪心 + 二分查找***
>   - 多玩一个新的数组。
>   - `Question 3` 的题意就是最长递增子序列的长度有没有大于等于 `3` 。

```java
class Solution {

    public boolean increasingTriplet(int[] nums) {
        return lengthOfLIS(nums) >= 3;
    }
    
    public int lengthOfLIS(int[] nums) {
        /*if (nums == null || nums.length == 0) {
            return 0;
        }*/
        // ends数组
        // ends[i]表示 : 目前所有长度为i+1的递增子序列的最小结尾
        int[] ends = new int[nums.length];
        // 根据含义, 一开始ends[0] = nums[0]
        ends[0] = nums[0];
        // ends有效区范围是0...right，right往右为无效区
        // 所以一开始right = 0, 表示有效区只有0...0范围
        int right = 0;
        // 最长递增子序列的长度
        // 全局变量，抓取每一步的答案，取最大的结果
        int max = 1;
        for (int i = 1; i < nums.length; i++) {
            int l = 0;
            int r = right;
            // 在ends[l...r]范围上二分
            // 如果 当前数(nums[i]) > ends[m]，砍掉左侧
            // 如果 当前数(nums[i]) <= ends[m]，砍掉右侧
            // 整个二分就是在ends里寻找 >= 当前数(nums[i])的最左位置
            // 就是从while里面出来时，l所在的位置。
            // 如果ends中不存在 >= 当前数(nums[i])的情况，将返回有效区的越界位置
            // 也就是从while里面出来时，l所在的位置，是有效区的越界位置
            // 比如 : ends = { 3, 5, 9, 12, 再往右无效}
            // 如果当前数为8, 从while里面出来时，l将来到2位置
            // 比如 : ends = { 3, 5, 9, 12, 再往右无效}
            // 如果当前数为13, 从while里面出来时，l将来到有效区的越界位置，4位置
            while (l <= r) {
                int m = (l + r) / 2;
                if (nums[i] > ends[m]) {
                    l = m + 1;
                } else {
                    r = m - 1;
                }
            }
            // 从while里面出来，看l的位置
            // 如果l比right大，说明扩充了有效区，那么right变量要随之变大
            // 如果l不比right大，说明l没有来到有效区的越界位置，right不变
            right = Math.max(right, l);
            // l的位置，就是当前数应该填到ends数组里的位置
            ends[l] = nums[i];
            // 更新全局变量
            max = Math.max(max, l + 1);
        }
        return max;
    }
    
}
```

> - ***Question 2: Question 1应用***
>   - 对于给定的一个序列，如果我们希望通过修改最少的元素，使得它单调递增，那么最少需要修改的元素个数（这些元素被改成和它相邻的元素一样或者满足在相邻元素值域内即可），就是序列的长度减去序列的最长递增子序列的长度。

```java
class Solution {

    public int kIncreasing(int[] arr, int k) {
        int ans = 0;
        // 如数组长度为5，k=2
        // 有的k步数组长度为2，有的为1
        // 向上取整
        int[] help = new int[(arr.length + k - 1) / k];
        for (int i = 0; i < k; i++) {
            // k步数组的大小和遍历索引
            int size = 0;
            // 填k步数组
            for (int kStep = i; kStep < arr.length; kStep += k, size++) {
                // arr[start , start + k, start + 2k, start + 3k,....]
                help[size] = arr[kStep];
            }
            // 计算最长递增子序列长度
            // 总长度减去就是要修改的
            ans += size - lengthOfLIS(help, size);
        }
        // 所有k步数组互不相干，每一个k步数组要改的元素数量和即为答案
        return ans;
    }

    public int lengthOfLIS(int[] nums, int size) {
        /*if (nums == null || nums.length == 0) {
            return 0;
        }*/
        // ends数组
        // ends[i]表示 : 目前所有长度为i+1的递增子序列的最小结尾
        int[] ends = new int[size];
        // 根据含义, 一开始ends[0] = nums[0]
        ends[0] = nums[0];
        // ends有效区范围是0...right，right往右为无效区
        // 所以一开始right = 0, 表示有效区只有0...0范围
        int right = 0;
        // 最长递增子序列的长度
        // 全局变量，抓取每一步的答案，取最大的结果
        int max = 1;
        for (int i = 1; i < size; i++) {
            int l = 0;
            int r = right;
            // 在ends[l...r]范围上二分
            // 如果 当前数(nums[i]) > ends[m]，砍掉左侧
            // 如果 当前数(nums[i]) <= ends[m]，砍掉右侧
            // 整个二分就是在ends里寻找 >= 当前数(nums[i])的最左位置
            // 就是从while里面出来时，l所在的位置。
            // 如果ends中不存在 >= 当前数(nums[i])的情况，将返回有效区的越界位置
            // 也就是从while里面出来时，l所在的位置，是有效区的越界位置
            // 比如 : ends = { 3, 5, 9, 12, 再往右无效}
            // 如果当前数为8, 从while里面出来时，l将来到2位置
            // 比如 : ends = { 3, 5, 9, 12, 再往右无效}
            // 如果当前数为13, 从while里面出来时，l将来到有效区的越界位置，4位置
            while (l <= r) {
                int m = (l + r) / 2;
                // 改这里，大于号变成大于等于！这样相等的时候也算作递增
                if (nums[i] >= ends[m]) {
                    l = m + 1;
                } else {
                    r = m - 1;
                }
            }
            // 从while里面出来，看l的位置
            // 如果l比right大，说明扩充了有效区，那么right变量要随之变大
            // 如果l不比right大，说明l没有来到有效区的越界位置，right不变
            right = Math.max(right, l);
            // l的位置，就是当前数应该填到ends数组里的位置
            ends[l] = nums[i];
            // 更新全局变量
            max = Math.max(max, l + 1);
        }
        return max;
    }

}
```

> - ***Question 4***
>   - 二维最长递增子序列问题，先将信封数组按照宽度由小到大，宽度相同长度由大到小排序。排序后提取出高度数组，对于这一个高度数组，同长度的但高度比我小的已经在我后面了，不会干扰我的选择，而一个普遍位置的信封的左边必然是宽度相同高度比它大或宽度比它小高度未知的数字，对这个提取出来的高度数组做一维最长递增子序列求解即可。

```java
class Solution {
    
    public int maxEnvelopes(int[][] envelops) {
        Envelope[] arr = sort(envelops);
        int[] ends = new int[envelops.length];
        ends[0] = arr[0].height;
        int right = 0;
        for (int i = 1; i < arr.length; i++) {
            int l = 0;
            int r = right;
            while (l <= r) {
                int m = (l + r) / 2;
                if (arr[i].height > ends[m]) {
                    l = m + 1;
                } else {
                    r = m - 1;
                }
            }
            right = Math.max(right, l);
            ends[l] = arr[i].height;
        }
        return right + 1;
    }
    
    public static class Envelope {
        
        public int weight;
        public int height;
        
        public Envelope(int weight, int height) {
            this.weight = weight;
            this.height = height;
        }
        
    }
    
    public static Envelope[] sort(int[][] envelops) {
        Envelope[] ans = new Envelope[envelops.length];
        for (int i = 0; i < envelops.length; i++) {
            ans[i] = new Envelope(envelops[i][0], envelops[i][1]);
        }
        Arrays.sort(ans, (o1, o2) -> o1.weight != o2.weight ? o1.weight - o2.weight : o2.height - o1.height);
        return ans;
    }
    
}
```

> - ***Question 5: 动态规划***
>   - 定义 `dp[i]` 表示以 `nums[i]` 结尾的最长上升子序列的长度， `cnt[i]` 表示以 `nums[i]` 结尾的最长上升子序列的个数。设 `nums` 的最长上升子序列的长度为 `maxLen` ，那么答案为所有满足 `dp[i] = maxLen` 的 `i` 所对应的 `cnt[i]` 之和。
>   - 我们从小到大计算 `dp` 数组的值，在计算 `dp[i]` 之前，我们已经计算出 `dp[0 ~ i − 1]` 的值，则状态转移方程为 `dp[i] = max(dp[j]) + 1, 0 <= j < i and num[j] < num[i]` 。
>   - 即考虑往 `dp[0 ~ i − 1]` 中最长的上升子序列后面再加一个 `nums[i]` 。由于 `dp[j]` 代表 `nums[0 ~ j]` 中以 `nums[j]` 结尾的最长上升子序列，所以如果能从 `dp[j]` 这个状态转移过来，那么 `nums[i]` 必然要大于 `nums[j]` ，才能将 `nums[i]` 放在 `nums[j]` 后面以形成更长的上升子序列。
>   - 对于 `cnt[i]` ，其等于所有满足 `dp[j] + 1 = dp[i]` 的 `cnt[j]` 之和。在代码实现时，我们可以在计算 `dp[i]` 的同时统计 `cnt[i]` 的值。

```java
class Solution {

    public int findNumberOfLIS(int[] nums) {
        int maxLen = 0, ans = 0;
        int[] dp = new int[nums.length];
        int[] cnt = new int[nums.length];
        for (int i = 0; i < nums.length; ++i) {
            dp[i] = 1;
            cnt[i] = 1;
            for (int j = 0; j < i; ++j) {
                if (nums[i] > nums[j]) {
                    if (dp[j] + 1 > dp[i]) {
                        dp[i] = dp[j] + 1;
                        cnt[i] = cnt[j]; // 重置计数
                    } else if (dp[j] + 1 == dp[i]) {
                        cnt[i] += cnt[j];
                    }
                }
            }
            if (dp[i] > maxLen) {
                maxLen = dp[i];
                ans = cnt[i]; // 重置计数
            } else if (dp[i] == maxLen) {
                ans += cnt[i];
            }
        }
        return ans;
    }

}
```

> - ***Question 5: 有序表 + 二分查找***
>   - 很难

```java
class Solution {
    
    // 优化后的最优解，时间复杂度O(N*logN)
    public static int findNumberOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        ArrayList<TreeMap<Integer, Integer>> dp = new ArrayList<>();
        int len = 0;
        int cnt = 0;
        for (int num : nums) {
            // num之前的长度，num到哪个长度len+1
            len = search(dp, num);
            // cnt : 最终要去加底下的记录，才是应该填入的value
            if (len == 0) {
                cnt = 1;
            } else {
                TreeMap<Integer, Integer> p = dp.get(len - 1);
                cnt = p.firstEntry().getValue() - (p.ceilingKey(num) != null ? p.get(p.ceilingKey(num)) : 0);
            }
            if (len == dp.size()) {
                dp.add(new TreeMap<Integer, Integer>());
                dp.get(len).put(num, cnt);
            } else {
                dp.get(len).put(num, dp.get(len).firstEntry().getValue() + cnt);
            }
        }
        return dp.get(dp.size() - 1).firstEntry().getValue();
    }
    
    // 二分查找，返回>=num最左的位置
    public static int search(ArrayList<TreeMap<Integer, Integer>> dp, int num) {
        int l = 0, r = dp.size() - 1, m = 0;
        int ans = dp.size();
        while (l <= r) {
            m = (l + r) / 2;
            if (dp.get(m).firstKey() >= num) {
                ans = m;
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        return ans;
    }
    
}
```

> - ***Question 6: 暴力递归***
>   - 从左往右的尝试模型。

```java
class Solution {

    // 暴力方法
    // 为了验证
    public static int number1(int n, int m) {
        return process1(0, n, m, new int[n]);
    }

    public static int process1(int i, int n, int m, int[] path) {
        if (i == n) {
            return lengthOfLIS(path) == 3 ? 1 : 0;
        } else {
            int ans = 0;
            for (int cur = 1; cur <= m; cur++) {
                path[i] = cur;
                ans += process1(i + 1, n, m, path);
            }
            return ans;
        }
    }

    public static int lengthOfLIS(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        int[] ends = new int[arr.length];
        ends[0] = arr[0];
        int right = 0;
        int max = 1;
        for (int i = 1; i < arr.length; i++) {
            int l = 0;
            int r = right;
            while (l <= r) {
                int m = (l + r) / 2;
                if (arr[i] > ends[m]) {
                    l = m + 1;
                } else {
                    r = m - 1;
                }
            }
            right = Math.max(right, l);
            ends[l] = arr[i];
            max = Math.max(max, l + 1);
        }
        return max;
    }

    // i : 目前来到的位置是i
    // i f s t 四维参数的递归！
    // dp[i][f][s][t]
    // 500 * 10 * 10 * 10 = 5 * 10^5
// public static int zuo(int i, int f, int s, int t, int n, int m) {
//  if (i == n) {
//   return t != 0 ? 1 : 0;
//  }
//  // i < n
//  // 1 ~ m
//  int ans = 0;
//  for (int num = 1; num <= m; num++) {
//   if (f == 0 || f >= num) {
//    ans += zuo(i + 1, num, s, t, n, m);
//   } else if (s == 0 || s >= num) {
//    ans += zuo(i + 1, f, num, t, n, m);
//   } else if (t == 0 || t >= num) {
//    ans += zuo(i + 1, f, s, num, n, m);
//   } else { // 都没拦住！最长递增子序列的长度将到达4！不合法了！
////    ans += 0;
//    break;
//   }
//  }
//  return ans;
// }

    // i : 当前来到的下标
    // f、s、t : ends数组中放置的数字！
    // ? == 0，没放！
    // n : 一共的长度！
    // m : 每一位，都可以在1~m中随意选择数字
    // 返回值：i..... 有几个合法的数组！
    public static int zuo(int i, int f, int s, int t, int n, int m) {
        if (i == n) {
            return f != 0 && s != 0 && t != 0 ? 1 : 0;
        }
        // i < n
        int ans = 0;
        for (int cur = 1; cur <= m; cur++) {
            if (f == 0 || f >= cur) {
                // f == 0说明最长递增子序列长度小于1
                // f >= cur说明长度为1的最长递增子序列的结尾数字可以换成当前数字
                // 后面代表长度为23
                ans += zuo(i + 1, cur, s, t, n, m);
            } else if (s == 0 || s >= cur) {
                ans += zuo(i + 1, f, cur, t, n, m);
            } else if (t == 0 || t >= cur) {
                ans += zuo(i + 1, f, s, cur, n, m);
            }
            // 只有以上情况可以继续往后面挑选数字，其他都不行
        }
        return ans;
    }

    // 正式方法
    // 需要看最长递增子序列！
    // 尤其是理解ends数组的意义！
    public static int number2(int n, int m) {
        int[][][][] dp = new int[n][m + 1][m + 1][m + 1];
        for (int i = 0; i < n; i++) {
            for (int f = 0; f <= m; f++) {
                for (int s = 0; s <= m; s++) {
                    for (int t = 0; t <= m; t++) {
                        dp[i][f][s][t] = -1;
                    }
                }
            }
        }
        return process2(0, 0, 0, 0, n, m, dp);
    }

    public static int process2(
            int i, int f, int s, int t,
            int n, int m, int[][][][] dp) {
        if (i == n) {
            return f != 0 && s != 0 && t != 0 ? 1 : 0;
        }
        if (dp[i][f][s][t] != -1) {
            return dp[i][f][s][t];
        }
        int ans = 0;
        for (int cur = 1; cur <= m; cur++) {
            if (f == 0 || cur <= f) {
                ans += process2(i + 1, cur, s, t, n, m, dp);
            } else if (s == 0 || cur <= s) {
                ans += process2(i + 1, f, cur, t, n, m, dp);
            } else if (t == 0 || cur <= t) {
                ans += process2(i + 1, f, s, cur, n, m, dp);
            }
        }
        dp[i][f][s][t] = ans;
        return ans;
    }

    public static void main(String[] args) {
        System.out.println("功能测试开始");
        for (int n = 4; n <= 8; n++) {
            for (int m = 1; m <= 5; m++) {
                int ans1 = number1(n, m);
                int ans2 = number2(n, m);
                if (ans1 != ans2) {
                    System.out.println(ans1);
                    System.out.println(ans2);
                    System.out.println("出错了!");
                }
            }
        }
        System.out.println("功能测试结束");
        System.out.println("性能测试开始");
        int n = 2000;
        int m = 20;
        System.out.println("序列长度 : " + n);
        System.out.println("数字范围 : " + m);
        long start = System.currentTimeMillis();
        number2(n, m);
        long end = System.currentTimeMillis();
        System.out.println("运行时间 : " + (end - start) + " 毫秒");
        System.out.println("性能测试结束");
    }

}
```

---

> ***last change: 2023/5/17***

---
