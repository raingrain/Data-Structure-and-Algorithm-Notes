# 1到n整数中1出现的次数

## [233. 数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/)

## [剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

> - ***Question***
>   - 输入一个整数 `n` ，求 `1 ~ n` 这 `n` 个整数的十进制表示中1出现的次数。
>   - 例如，输入 `12` ， `1 ~ 12` 这些整数中包含 `1` 的数字有 `1, 10, 11, 12` ， `1` 一共出现了 `5` 次。
>   - ***tips:***
>     - `1 <= n < 2^31`

---

## *Java*

> - ***数位DP***

```java
class Solution {
    
    public int countDigitOne(int num) {
        if (num < 1) {
            return 0;
        }
        // 获取数字长度
        int len = getLenOfNum(num);
        // 1 ~ (0,...,9)都只有1个1
        if (len == 1) {
            return 1;
        }
        // num 13625
        // temp 10000
        // num 7872328738273
        // temp 1000000000000
        int temp = (int) Math.pow(10, len - 1);
        // 第一位数字是几
        int first = num / temp;
        // 第一位上有几个1
        int firstOneNum = first == 1 ? num % temp + 1 : temp;
        // 剩下的位上有几个1
        int otherOneNum = first * (len - 1) * (temp / 10);
        // 如1364分为1~364和365~1364
        // 我们计算365到1364，分开计算每个数字能给个十百千位上贡献几个1
        // 对于千位为365
        // 对于百位，我们发现在十位和个位上0~9随意选择有10*10个
        // 对于十位，我们在百位和个位上随意选择有100
        // 个位在百位和十位上选择，也一样
        // 即选好后只有千位上只有一个选择能让这个数字在要求的范围内
        // 对于365到5364
        // 我们要手动计算这些的话
        // 分成365~1364，1365~2364，2365~3364，3365~4363，4365~5364这5个组，刚刚的结论每个组的结果都一样通项公式乘5即可
        // 后者的1就是firstOneNum + otherOneNum
        // 剩下的部分递归去算
        return firstOneNum + otherOneNum + countDigitOne(num % temp);
    }
    
    private int getLenOfNum(int num) {
        int len = 0;
        while (num != 0) {
            len++;
            num /= 10;
        }
        return len;
    }
    
}
```

---

> ***last change: 2023/4/9***

---
