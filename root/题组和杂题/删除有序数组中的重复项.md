# 删除有序数组中的重复项

## [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

## [80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

> - ***Question 1***
>   - 给你一个升序排列的数组 `nums` ，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。
>   - 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组 `nums` 的第一部分。更规范地说，如果在删除重复项之后有 `k` 个元素，那么 `nums` 的前 `k` 个元素应该保存最终结果。
>   - 将最终结果插入 `nums` 的前 `k` 个位置后返回 `k` 。
>   - 不要使用额外的空间，你必须在原地修改输入数组并在使用 `O(1)` 额外空间的条件下完成。
> - ***Question 2***
>   - 给你一个有序数组 `nums` ，请你原地删除重复出现的元素，使得出现次数超过两次的元素只出现两次，返回删除后数组的新长度。
>   - 不要使用额外的空间，你必须在原地修改输入数组并在使用 `O(1)` 额外空间的条件下完成。
> - ***tips:***
>   - `1 <= nums.length <= 3 * 10^4`
>   - `-10^4 <= nums[i] <= 10^4`
>   - `nums` 已按升序排列

---

## *Java*

> - ***基于双指针思想出现次数超过k次的元素只保留k次的通解***
>   - 由于是保留 `k` 个相同数字，对于前 `k` 个数字，我们可以直接保留。
>   - 对于后面的任意数字，能够保留的前提是与当前写入的位置（准备要写入的那个位置，即已经填好的下一个）前面的第 `k` 个元素进行比较，不相同则保留。
>   - 我们令 `k = 2` ，假设有如下样例 `[1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3]` ：
>     - 首先我们先让前 `2` 位直接保留得到 `1, 1` 。
>     - 对后面的每一位进行继续遍历，能够保留的前提是与当前位置的前面 `k` 个元素不同（答案中的第一个 `1` ），因此我们会跳过剩余的 `1` 并将第一个 `2` 追加得到 `1, 1, 2` 。
>     - 继续这个过程，这时候是和答案中的第 `2` 个 `1` 进行对比，因此可以得到 `1, 1, 2, 2` 。
>     - 这时候和答案中的第 `1` 个 `2` 比较，只有与其不同的元素能追加到答案，因此剩余的 `2` 被跳过， `3` 被追加到答案得到 `1, 1, 2, 2, 3` 。

```java
class Solution {
    
    public int removeDuplicates(int[] nums) {
        // 保留一次和两次
        // return remove(nums, 1);
        return remove(nums, 2);
    }
    
    private int remove(int[] nums, int k) {
        int left = 0;
        // 迭代器本质上就是右指针
        for (int num : nums) {
            // left < k是前k个
            // nums[left - k] != num与要填入位置的前k个不同
            if (left < k || nums[left - k] != num) {
                // 填入，然后左指针移动到下一个填入位置
                nums[left++] = num;
            }
        }
        // 保存的是下一个位置，和长度一样
        return left;
    }
    
}
```

---

> ***last change: 2022/11/29***

---
