# 复制粘贴键盘

## [650. 只有两个键的键盘](https://leetcode.cn/problems/2-keys-keyboard/)

> - ***Question 1***
>   - 最初记事本上只有一个字符 `A` 。你每次可以对这个记事本进行两种操作：
>     - `Copy All` （复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
>     - `Paste` （粘贴）：粘贴上一次复制的字符。
>   - 给你一个数字 `n` ，你需要使用最少的操作次数，在记事本上输出恰好 `n` 个 `A` 。返回能够打印出 `n` 个 `A` 的最少操作次数。
>   - ***tips:***
>     - `1 <= n <= 1000`

## [651. 4键键盘](https://leetcode.cn/problems/4-keys-keyboard/)

> - ***Question 2***
>   - 一开始记事本和粘贴板上什么都没有。你每次可以做四个操作：
>     - 输入：在屏幕上打印一个 `A` 。
>     - 全选：选中所有的 `A` 。
>     - 复制：复制全选中的内容到粘贴板。
>     - 粘贴：在屏幕上打印粘贴板中的内容。
>   - 给你一个数字 `n` ，返回 `n` 步操作内你最多能让多少个 `A` 显示在屏幕上。

## Java

> - ***Question 1: 动态规划***

```java
class Solution {
    
    public int minSteps(int n) {
        // dp[i]表示打印出i个A所需的最少操作次数
        int[] dp = new int[n + 1];
        // dp[0]无效
        // 最开始有一个1，dp[1]=0
        for (int i = 2; i <= n; ++i) {
            dp[i] = Integer.MAX_VALUE;
            // 要想打印出i个A，我们首先需要有j个A，然后经过i/j次粘贴操作得到i个A，所以j是i的因子，我们枚举所有因子，找到代价最小的
            // dp[i] = min{dp[j] + j / i} (j | i)
            // 枚举的j最多到根号i，因为j和i/j肯定有一个小于根号i，得到一个同时枚举另外一个即可
            for (int j = 1; j * j <= i; ++j) {
                if (i % j == 0) {
                    dp[i] = Math.min(dp[i], dp[j] + i / j);
                    dp[i] = Math.min(dp[i], dp[i / j] + j);
                }
            }
        }
        return dp[n];
    }
    
}
```

> - ***Question 2: 动态规划 + 贪心***

```java
class Solution {
    
    // 可以证明：
    // 来到i的时候，包括i在内最多有连续4次粘贴行为
    // 不可能更多，如果有连续5次粘贴，一定就不再是最优解
    // 假设开始时，A的数量为S，看如下的变化过程，我们称这是行为一：
    // 开始  全选  复制(粘贴板S个A)  粘贴  粘贴  粘贴  粘贴  粘贴
    // S      S         S         2*S  3*S   4*S  5*S  6*S
    // 但是，注意看如下的行为二：
    // 开始  全选  复制(粘贴板S个A)  粘贴  全选  复制(粘贴板2S个A) 粘贴   粘贴
    // S      S         S         2*S  2*S        2*S        4*S   6*S
    // 行为一，经历8步，最后是6*S个A
    // 行为二，经历8步，最后是6*S个A
    // 但是行为二在粘贴板上有2S个A，而行为一在粘贴板上有S个A
    // 所以行为一没有行为二优
    // 以此说明：来到i的时候，包括i在内最多有连续4次粘贴行为
    // 那么就尝试：连续1次、连续2次、连续3次、连续4次粘贴行为即可
    // 举例，连续一次粘贴代表i-3步的个数在i-2步被全选，i-1步被复制，i步粘贴上去，结果为dp[i - 3] * 2个A字符
    // 连续两次粘贴代表i-4步的个数在i-3步被全选，i-2步被复制，i-1和i步粘贴上去，结果为dp[i - 4] * 3个A字符
    // ...
    public int maxA(int n) {
        // dp[0] 1步以内的最优解
        // dp[1] 2步以内的最优解
        // dp[2] 3步以内的最优解
        // dp[i] i+1步以内的最优解
        int[] dp = new int[n];
        for (int i = 0; i < 6 && i < n; i++) {
            // 前6步直接粘贴即可
            dp[i] = i + 1;
        }
        for (int i = 6; i < n; i++) {
            dp[i] = Math.max(
                    Math.max(dp[i - 3] * 2, dp[i - 4] * 3),
                    Math.max(dp[i - 5] * 4, dp[i - 6] * 5));
        }
        return dp[n - 1];
    }
    
}
```
