# 子数组的最大累加和

## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

## [剑指 Offer 42. 连续子数组的最大和](https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

> - ***Question***
>   - 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。要求时间复杂度为 `O(n)` 。
>   - 如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的分治法求解。
>   - ***tips:***
>     - `1 <= nums.length <= 10^5`
>     - `-10^4 <= nums[i] <= 10^4`

---

## *Java*

> - ***动态规划***

```java
class Solution {
    
    public int maxSubArray(int[] nums) {
        int pre = nums[0];
        int ans = nums[0];
        for (int i = 1; i < nums.length; i++) {
            pre = Math.max(nums[i], pre + nums[i]);
            ans = Math.max(ans, pre);
        }
        return ans;
    }
    
}
```

> - ***分治***
>   - 我们定义一个操作 `get(arr, left, right)` 表示查询 `arr` 序列 `[left, right]` 区间内的最大子段和，那么最终我们要求的答案就是 `get(nums, 0, nums.size() - 1)` 。如何分治实现这个操作呢？对于一个区间 `[left, right]` ，我们取 `mid = (left + right) / 2` ，对区间 `[left, mid]` 和 `[mid + 1, right]` 分治求解。当递归逐层深入直到区间长度缩小为 `1` 的时候，递归开始回升。这个时候我们考虑如何通过 `[left, mid]` 区间的信息和 `[mid + 1, right]` 区间的信息合并成区间 `[left, right]` 的信息。最关键的两个问题是：
>     - 我们要维护区间的哪些信息呢？
>     - 我们如何合并这些信息呢？
>   - 对于一个区间 `[left, right]` ，我们可以维护四个量：
>     - `lSum` 表示 `[left, right]` 内以 `left` 为左端点的最大子段和。
>     - `rSum` 表示 `[left, right]` 内以 `right` 为右端点的最大子段和。
>     - `mSum` 表示 `[left, right]` 内的最大子段和。
>     - `iSum` 表示 `[left, right]` 的区间和。
>   - `[left, mid]` 为 `[left, right]` 的左子区间， `[mid + 1, right]` 为 `[left, right]` 的右子区间。我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到 `[left, right]` 的信息）？对于长度为 `1` 的区间 `[i, i]` ，四个量的值都和 `nums[i]` 相等。对于长度大于 `1` 的区间：
>     - 首先最好维护的是 `iSum` ，区间 `[left, right]` 的 `iSum` 就等于左子区间的 `iSum` 加上右子区间的 `iSum` 。
>     - 对于 `[left, right]` 的 `lSum` ，存在两种可能，它要么等于左子区间的 `lSum` ，要么等于左子区间的 `iSum` 加上右子区间的 `lSum` ，二者取大。
>     - 对于 `[left, right]` 的 `rSum` ，同理，它要么等于右子区间的 `rSum` ，要么等于右子区间的 `iSum` 加上左子区间的 `rSum` ，二者取大。
>     - 当计算好上面的三个量之后，就很好计算 `[left, right]` 的 `mSum` 了。我们可以考虑 `[left, right]` 的 `mSum` 对应的区间是否跨越 `mid` 。它可能不跨越 `mid` ，也就是说 `[left, right]` 的 `mSum` 可能是左子区间的 `mSum` 和右子区间的 `mSum` 中的一个；它也可能跨越 `mid` ，可能是左子区间的 `rSum` 和右子区间的 lSum 求和。三者取大。

```java
class Solution {
    
    public static class Status {
        
        public int lSum, rSum, mSum, iSum;
        
        public Status(int lSum, int rSum, int mSum, int iSum) {
            this.lSum = lSum;
            this.rSum = rSum;
            this.mSum = mSum;
            this.iSum = iSum;
        }
        
    }
    
    public int maxSubArray(int[] nums) {
        return getInfo(nums, 0, nums.length - 1).mSum;
    }
    
    public Status getInfo(int[] arr, int left, int right) {
        if (left == right) {
            return new Status(arr[left], arr[left], arr[left], arr[left]);
        }
        int mid = (left + right) >> 1;
        Status lStatus = getInfo(arr, left, mid);
        Status rStatus = getInfo(arr, mid + 1, right);
        return pushUp(lStatus, rStatus);
    }
    
    public Status pushUp(Status left, Status right) {
        int iSum = left.iSum + right.iSum;
        int lSum = Math.max(left.lSum, left.iSum + right.lSum);
        int rSum = Math.max(right.rSum, right.iSum + left.rSum);
        int mSum = Math.max(Math.max(left.mSum, right.mSum), left.rSum + right.lSum);
        return new Status(lSum, rSum, mSum, iSum);
    }
    
}
```

---

> ***last change: 2023/3/10***

---
