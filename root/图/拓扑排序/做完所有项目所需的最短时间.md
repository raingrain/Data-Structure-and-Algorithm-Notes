# 做完所有项目所需的最短时间

## 网易

> - ***Question***
>   - 每个项目都有固定的完成所需时间，并且可能需要先完成其他项目才能做当前项目，当多个项目可以并行完成，请你返回做完所有项目所需的最短时间。

---

## *Java*

> - ***拓扑排序 + 类dijkstra的更新***

```java
class Solution {
    
    // adjacencyMap是邻接表，索引对应的下一级是存储在一个list里面的
    // in是入度表
    // days[i]表示做完i号任务需要几天
    public static int dayCount(ArrayList<Integer>[] adjacencyMap, int[] days, int[] in) {
        // 初始化队列
        ArrayDeque<Integer> head = countHead(in);
        // countDays[i]表示做到且做完第i号项目所需的最短时间
        int[] countDays = new int[days.length];
        // 队列不为空
        while (!head.isEmpty()) {
            int cur = head.poll();
            // 当前天先加上本来要做完需要的时间
            countDays[cur] += days[cur];
            // 查看依赖它的所有项目
            for (int j = 0; j < adjacencyMap[cur].size(); j++) {
                // 入度减一
                in[adjacencyMap[cur].get(j)]--;
                // 入度变为0，去队列
                if (in[adjacencyMap[cur].get(j)] == 0) {
                    head.offer(adjacencyMap[cur].get(j));
                }
                // 因为这个项目是依赖我的，我看看我需要做的时间比不比它记录的大，大就推高
                countDays[adjacencyMap[cur].get(j)] = Math.max(countDays[adjacencyMap[cur].get(j)], countDays[cur]);
            }
        }
        // 遍历所有，返回最大时间作为答案
        int maxDay = 0;
        for (int count : countDays) {
            maxDay = Math.max(maxDay, count);
        }
        return maxDay;
    }
    
    // 把所有入度为0的项目加到队列中
    private static ArrayDeque<Integer> countHead(int[] headCount) {
        ArrayDeque<Integer> queue = new ArrayDeque<>();
        for (int i = 0; i < headCount.length; i++) {
            if (headCount[i] == 0)
                queue.offer(i); // 没有前驱任务
        }
        return queue;
    }
    
}
```

---

> ***last change: 2023/4/21***

---
