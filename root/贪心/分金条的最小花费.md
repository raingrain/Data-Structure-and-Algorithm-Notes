# 分金条的最小花费

## 程序员代码面试指南：IT名企算法与数据结构题目最优解（第二版） 第8章 数组和矩阵问题 分金条的最小花费

> - ***Question***
>   - 给定一个正数数组 `arr` ， `arr` 的累加和代表金条的总长度， `arr` 的每个数代表金条要分成的长度，规定长度为 `K` 的金条只需分成两块，费用为 `K` 个铜板。返回把金条分出 `arr` 中的每个数字需要的最小代价
>   - ***examples:***
>     - 输入长为 `60` 的金条，分成 `[10, 20, 30]`
>     - 每次分割都会产生同样花费的消耗，比如 `60` 切成 `10` 和 `50` ，就花费 `60`
>     - `60` 先分成 `10` 和 `50` ， `50` 再分成 `20` 和 `30` ，消耗 `10 + 50 + 20 + 30`
>     - 也可以 `60` 先分成 `30` 和 `30` ， `30` 再分成 `10` 和 `20` ，消耗 `30 + 30 + 10 + 20`
>     - 分别消耗 `110` 和 `90` ，选后者

---

## *Java*

> - ***贪心***
>   - 利用哈夫曼编码原理，直接建立一个小根堆，然后每次都获取小根堆中的前两个数，相加得到新的数再加入到小根堆中，直到最后剩下一个数时候退出，这其实是自底向上建立一颗哈夫曼树的过程，每一个在循环中建立的节点（求和的那个节点）都是你最优切分的步骤之一，
>   - 从树上自顶向下看分割顺序即为每个新建的节点，自底向上看是一个合并金条的过程
> - ***暴力递归***

```java
class Solution {
    
    public int lessMoney(int[] nums) {
        // return lessMoneyByViolence(nums);
        return lessMoneyByGreedy(nums);
    }
    
    public int lessMoneyByViolence(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        return process(nums, 0);
    }
    
    // 暴力递归过程
    // 等待切割的数字还在nums里面，之前产生的花费为pre
    public int process(int[] nums, int pre) {
        // 数组中长度为1时，不用分割了
        if (nums.length == 1) {
            return pre;
        } else {
            int ans = Integer.MAX_VALUE;
            // 从数组中任意抽取两个数，枚举所有情况
            for (int i = 0; i < nums.length; i++) {
                for (int j = i + 1; j < nums.length; j++) {
                    // 暴力递归，看合并i，j后的代价和上一种合并的代价哪个小，既获得当前数组合并两个数的最优方案
                    ans = Math.min(ans, process(copyAndMergeArray(nums, i, j), pre + nums[i] + nums[j]));
                }
            }
            return ans;
        }
    }
    
    // 把i，j位置的数合并起来放在新数组的最后，然后剩下的拷贝，返回新的
    public int[] copyAndMergeArray(int[] arr, int i, int j) {
        int[] ans = new int[arr.length - 1];
        int ansi = 0;
        for (int arri = 0; arri < arr.length; arri++) {
            if (arri != i && arri != j) {
                ans[ansi++] = arr[arri];
            }
        }
        ans[ansi] = arr[i] + arr[j];
        return ans;
    }
    
    // 贪心
    public int lessMoneyByGreedy(int[] nums) {
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        for (int num : nums) {
            queue.add(num);
        }
        int ans = 0;
        int sum = 0;
        while (queue.size() > 1) {
            sum = queue.poll() + queue.poll();
            ans += sum;
            queue.add(sum);
        }
        return ans;
    }
    
}
```

---

> ***last change: 2022/10/27***

---
