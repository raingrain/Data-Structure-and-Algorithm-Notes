# 两条无环单链表的第一个公共节点

## [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

## [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

## [剑指 Offer II 023. 两个链表的第一个重合节点](https://leetcode.cn/problems/3u1WK4/)

> - ***Question 1***
>   - 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点
>   - 如果两个链表不存在相交节点，返回 `null`  
>   - ***tips:***
>     - 题目数据保证整个链式结构中不存在环 
>     - 函数返回结果后，链表必须保持其原始结构
>     - `intersectVal` 为相交的起始节点的值。如果不存在相交节点，这一值为 `0`  
>     - `listA` 为第一个链表 
>     - `listB` 为第二个链表 
>     - `skipA` 为在 `listA` 中（从头节点开始）跳到交叉节点的节点数 
>     - `skipB` 为在 `listB` 中（从头节点开始）跳到交叉节点的节点数
>     - `listA` 中节点数目为 `m` 
>     - `listB` 中节点数目为 `n` 
>     - `1 <= m, n <= 3 * 104`   
>     - `1 <= Node.val <= 105`   
>     - `0 <= skipA <= m`   
>     - `0 <= skipB <= n`   
>     - 如果 `listA` 和 `listB` 没有交点， `intersectVal` 为 `0` 
>     - 如果 `listA` 和 `listB` 有交点， `intersectVal == listA[skipA] == listB[skipB]`
> - ***Question 2***
>   - 假设两个链表可能有环，又怎么做？

---

## *Java*

> - 首先明确一点，只要有一个为空就必定不相交，尾节点不同也必定不相交，相交必定呈 `Y` 型
> - ***普通遍历***
>   - 先找到两个链表的尾节点和两个链表长度的差值
>   - 尾节点相等则相交
>   - 相交的话找到长链表先走差值步，这时其剩余长度等于短链表
>   - 两个指针同时出发必然在第一个相交节点处相遇
> - ***容器遍历***
>   - 容器的思想就是说把 `listA` 丢进集合里面，然后遍历 `listB` ，在集合中查找 `listA` 有没有等于 `listB` 的，只要有，那这个节点就是相交节点
>   - 时间复杂度O(m + n)，空间复杂度O(m)
> - ***双指针***
>   - 当链表 `headA` 和 `headB` 都不为空时，创建两个指针 `pA` 和 `pB` ，初始时分别指向两个链表的头节点 `headA` 和  `headB` ，然后将两个指针依次遍历两个链表的每个节点， 具体做法如下： 
>     - 每步操作需要同时更新指针 `pA` 和 `pB` 
>     - 如果指针 `pA` 不为空，则将指针 `pA` 移到下一个节点 
>     - 如果指针 `pB` 不为空，则将指针 `pB` 移到下一个节点 
>     - 如果指针 `pA` 为空，则将指针 `pA` 移到链表 `headB` 的头节点 
>     - 如果指针 `pB` 为空，则将指针 `pB` 移到链表 `headA` 的头节点 
>     - 当指针 `pA` 和 `pB` 指向同一个节点或者都为空时，返回它们指向的节点或者 `null`
>   - 证明考虑两种情况，第一种情况是两个链表相交，第二种情况是两个链表不相交： 
>      - 情况一，两个链表相交，链表 `headA` 和 `headB` 的长度分别是 `m` 和 `n`，假设链表 `headA` 的不相交部分有 `a` 个节点，链表 `headB` 的不相交部分有 `b` 个节点，两个链表相交的部分有 `c` 个节点，则有 `a + c = m` ， `b + c = n` ：
>        - 如果 `a=b` ，则两个指针会同时到达两个链表相交的节点，此时返回相交的节点
>        - 如果 `a != b` ，则指针 `pA` 会遍历完链表 `headA` ，指针 `pB` 会遍历完链表 `headB` ，两个指针不会同时到达链表的尾节点，然后指针 `pA` 移到链表 `headB` 的头节点，指针 `pB` 移到链表 `headA` 的头节点，然后两个指针继续移动，在指针 `pA` 移动了 `a + c + b` 次、指针 `pB` 移动了 `b + c + a` 次之后，两个指针会同时到达两个链表相交的节点，该节点也是两个指针第一次同时指向的节点，此时返回相交的节点 
>      - 情况二，两个链表不相交，链表 `headA` 和 `headB` 的长度分别是 `m` 和 `n` ：
>        - 如果 `m = n` ，则两个指针会同时到达两个链表的尾节点，然后同时变成空值 `null` ，此时返回 `null` 
>        - 如果 `m != n` ，则由于两个链表没有公共节点，两个指针也不会同时到达两个链表的尾节点，因此两个指针都会遍历完两个链表，在指针 `pA` 移动了 `m + n` 次、指针 `pB` 移动了  `n + m` 次之后，两个指针会同时变成空值 `null` ，此时返回 `null`
>    - 时间复杂度O(m + n)，空间复杂度O(1)
> - ***假设两个链表有环***
>   - 假如一个有环一个无环，那两个单链表必定不可能相交
>   - 如果两个链表都有环，可以分为3种情况：不相交；相交且在入环前或者入环时相交；环相交但入环节点不同：
>     - 对于第二种情况我们要先获得链表的入环节点，然后把入环节点作为尾节点，找两个无环链表的相交节点
>     - 如果入环节点不相等那就是第一种或者第三种情况，我们从链表A的入环节点开始在环中进动，如果转了一圈还没有碰见链表B的入环节点就是不相交，不然就相交，返回两个入环节点之一

### 代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 双指针
        return getIntersectionNodeByDoublePoint(headA, headB);
        // 使用指针
        // return getIntersectionNodeByPoint(headA, headB);
        // 使用容器
        // return getIntersectionNodeByArrayList(headA, headB);
    }

    // 双指针
    public ListNode getIntersectionNodeByDoublePoint(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        } else {
            ListNode pA = headA, pB = headB;
            while (pA != pB) {
                pA = pA == null ? headB : pA.next;
                pB = pB == null ? headA : pB.next;
            }
            return pA;
        }
    }

    // 指针
    public ListNode getIntersectionNodeByPoint(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        } else {
            ListNode cur1 = headA;
            ListNode cur2 = headB;
            int n = 0;
            // 这种终止条件使得cur会停在尾节点而不是空
            while (cur1.next != null) {
                n++;
                cur1 = cur1.next;
            }
            while (cur2.next != null) {
                n--;
                cur2 = cur2.next;
            }
            // 如果两个尾节点不相等那必然不相交
            if (cur1 != cur2) {
                return null;
            } else {
                // 把cur1设置为长的链表，cur2设置为短的，等于的话B是长的
                cur1 = n > 0 ? headA : headB;
                cur2 = cur1 == headA ? headB : headA;
                n = Math.abs(n);
                // n取绝对值就是两条链表之间长度的差值，长链表先走
                while (n != 0) {
                    n--;
                    cur1 = cur1.next;
                }
                // 这时候两链表剩余长度相同
                while (cur1 != cur2) {
                    cur1 = cur1.next;
                    cur2 = cur2.next;
                }
                return cur1;
            }
        }
    }

    // 容器
    public ListNode getIntersectionNodeByArrayList(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        } else {
            ArrayList<ListNode> arr = new ArrayList<>();
            ListNode cur = headA;
            while (cur != null) {
                arr.add(cur);
                cur = cur.next;
            }
            cur = headB;
            while (cur != null) {
                if (arr.contains(cur)) {
                    return cur;
                }
                cur = cur.next;
            }
            return null; 
        }
    }
}
```

---

> ***last change: 2022/10/12***

---
