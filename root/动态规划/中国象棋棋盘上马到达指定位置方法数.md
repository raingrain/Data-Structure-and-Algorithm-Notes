# 中国象棋棋盘上马到达指定位置方法数

## 京东笔试

> - ***Question***
>   - 把整个棋盘放在第一象限，左下角为原点 `(0, 0)` ，给你 `(a, b)` 和 `k` ，问马从原点出发，以日字型移动，在 `k` 步内到达 `(a, b)` 的方法数有几种？棋盘大小为横坐标上 `9` 条线，纵坐标上 `10` 条线。

---

## *Java*

> - ***暴力递归***

```java
class Solution {
    
    public static int jump(int a, int b, int k) {
        return recursion(0, 0, a, b, k);
    }
    
    // 递归含义：马从(i, j)位置出发到(a, b)位置，还剩下rest能走，求能到达(a, b)位置的方法数
    public static int recursion(int i, int j, int a, int b, int rest) {
        // 越界返回0
        if (i < 0 || i > 9 || j < 0 || j > 8) {
            return 0;
        }
        if (rest == 0) {
            // 之前的尝试成功了，也就是一个递归树的一条分支成立
            return (i == a && j == b) ? 1 : 0;
        }
        int ways = 0;
        // 从一个普遍位置出发，马有8个位置可以去
        ways += recursion(i + 1, j + 2, a, b, rest - 1);
        ways += recursion(i - 1, j + 2, a, b, rest - 1);
        ways += recursion(i - 2, j + 1, a, b, rest - 1);
        ways += recursion(i - 2, j - 1, a, b, rest - 1);
        ways += recursion(i - 1, j - 2, a, b, rest - 1);
        ways += recursion(i + 1, j - 2, a, b, rest - 1);
        ways += recursion(i + 2, j - 1, a, b, rest - 1);
        ways += recursion(i + 2, j + 1, a, b, rest - 1);
        return ways;
        
    }
    
    public static void main(String[] args) {
        // 821776
        System.out.println(jump(7, 5, 10));
    }
    
}
```

> - ***动态规划***
>   - 三维动态规划，注意越界部分的处理。

```java
class Solution {
    
    public static int jump(int a, int b, int k) {
        return dp(a, b, k);
    }
    
    public static int dp(int a, int b, int k) {
        int[][][] dp = new int[10][9][k + 1];
        dp[a][b][0] = 1;
        for (int rest = 1; rest < k + 1; ++rest) {
            for (int i = 0; i < 10; ++i) {
                for (int j = 0; j < 9; ++j) {
                    int ways = 0;
                    ways += pick(dp, i + 1, j + 2, rest - 1);
                    ways += pick(dp, i - 1, j + 2, rest - 1);
                    ways += pick(dp, i - 2, j + 1, rest - 1);
                    ways += pick(dp, i - 2, j - 1, rest - 1);
                    ways += pick(dp, i - 1, j - 2, rest - 1);
                    ways += pick(dp, i + 1, j - 2, rest - 1);
                    ways += pick(dp, i + 2, j - 1, rest - 1);
                    ways += pick(dp, i + 2, j + 1, rest - 1);
                    dp[i][j][rest] = ways;
                }
            }
        }
        return dp[0][0][k];
    }
    
    // 如果数组越界返回0，不然真的返回dp表中的值
    // 避免在循环里面的判断
    public static int pick(int[][][] dp, int i, int j, int rest) {
        return (i < 0 || i > 9 || j < 0 || j > 8) ? 0 : dp[i][j][rest];
    }
    
    public static void main(String[] args) {
        // 821776
        System.out.println(jump(7, 5, 10));
    }
    
}
```

---

> ***last change: 2023/1/26***

---
