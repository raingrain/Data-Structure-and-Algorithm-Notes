# 零钱兑换相关问腿

## 零钱兑换IV

> - ***Question 1***
>   - 你的钱包 `money` 里面有一些钱，我们认为面值相同的每一张钱各不相同，请你凑出指定面值 `aim` ，返回方法数。
>   - 例如 `money = [1, 1, 1]` ，请你凑出面值为 `2` ，很显然答案为 `3` ，即第一张和第二张、第二张和第三张或第一张和第三张都行。

## [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

> - ***Question 2***
>   - 给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。
>   - 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。
>   - 假设每一种面额的硬币有无限个。
>   - ***tips:***
>     - `1 <= coins.length <= 300`
>     - `1 <= coins[i] <= 5000`
>     - `coins` 中的所有值互不相同
>     - `0 <= amount <= 5000`

## 零钱兑换III

> - ***Question 3***
>   - 你的钱包 `money` 里面有一些钱，我们认为面值相同的每一张钱是相同的，请你凑出指定面值 `amount` ，返回方法数。
>   - 例如 `money = [1, 2, 1, 1, 2, 1, 2]` ， `amount = 4` ，有 `1+1+1+1, 1+1+2, 2+2` 这 `3` 种凑法。
>   - 你可以认为这就是 `Question 2` 的改进版本，即将第二题中的无限硬币改成有限个的，可以整理出一个面值数组和与之对应的数量数组。

## [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

> - ***Question 4***
>   - 给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。
>   - 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。
>   - 你可以认为每种硬币的数量是无限的。
>   - ***tips:***
>     - `1 <= coins.length <= 12`
>     - `1 <= coins[i] <= 2^31 - 1`
>     - `0 <= amount <= 10^4`

---

## *Java*

> - ***Question 1: 暴力递归 & 动态规划***
>   - 一例比较简单基于从左往右的尝试模型的题目，但我们注意到，出现了依赖位置可能不在dp表中的情况，需要做判断。

```java
class Solution {
    
    // 递归含义：返回arr[index……]上的钱组成rest面额的方法数
    public static int recursion(int[] money, int index, int rest) {
        if (rest < 0) {
            return 0;
        }
        if (index == money.length) {
            return rest == 0 ? 1 : 0;
        }
        // 对于每一个index位置的钱来说只有拿或者不拿两种选择
        return recursion(money, index + 1, rest) + recursion(money, index + 1, rest - money[index]);
    }
    
    public static int dp(int[] money, int aim) {
        int[][] dp = new int[money.length + 1][aim + 1];
        dp[money.length][0] = 1;
        for (int index = money.length - 1; index >= 0; --index) {
            for (int rest = 0; rest < aim + 1; ++rest) {
                dp[index][rest] = dp[index + 1][rest] + (rest - money[index] >= 0 ? dp[index + 1][rest - money[index]] : 0);
            }
        }
        return dp[0][aim];
    }
    
    public static void main(String[] args) {
        int[] money = new int[]{1, 1, 2, 3, 1, 1, 3, 1, 2, 4, 5, 6, 3};
        // 145
        System.out.println(recursion(money, 0, 7));
        System.out.println(dp(money, 7));
    }
    
}
```

> - ***Question 2: 暴力递归***
>   - 从左往右的尝试模型，超时。

```java
class Solution {
    
    public int change(int amount, int[] coins) {
        return recursion(coins, 0, amount);
    }
    
    // 递归含义：在coins[index……]中拿到rest面额的钱的方法数
    // index：0-coins.length
    // rest：0-amount
    public int recursion(int[] coins, int index, int rest) {
        if (index == coins.length) {
            // 遍历到没有面值结束
            return rest == 0 ? 1 : 0;
        }
        int ans = 0;
        // 如果钱还没拿完就已经凑够了，往下一级递归传时会由于zhang * coins[index] <= rest这一判断条件直接跳出for循环，返回0或者不完全遍历完的情况
        // 保证拿的钱不超过我想要的，zhang * coins[index]是我本次拿的
        for (int zhang = 0; zhang * coins[index] <= rest; ++zhang) {
            ans += recursion(coins, index + 1, rest - zhang * coins[index]);
        }
        return ans;
    }
    
}
```

> - ***Question 2: 动态规划***

```java
class Solution {
    
    public int change(int amount, int[] coins) {
        return dp(amount, coins);
    }
    
    public int dp(int amount, int[] coins) {
        int[][] dp = new int[coins.length + 1][amount + 1];
        dp[coins.length][0] = 1;
        for (int index = coins.length - 1; index >= 0; --index) {
            for (int rest = 0; rest < amount + 1; ++rest) {
                int ans = 0;
                // 与往常不同，在填值时需要循环枚举
                // 如果单独一个格子没有枚举行为，记忆化搜索和严格表结构的时间复杂度一样
                for (int zhang = 0; zhang * coins[index] <= rest; ++zhang) {
                    ans += dp[index + 1][rest - zhang * coins[index]];
                }
                dp[index][rest] = ans;
            }
        }
        return dp[0][amount];
    }
    
}
```

> - ***Question 2: 动态规划 + 空间位置优化***
>   - 如果在暴力递归中发现需要进行for循环，这意味着可以进行空间位置优化。

```java
class Solution {
    
    public int change(int amount, int[] coins) {
        return dp(amount, coins);
    }
    
    public int dp(int amount, int[] coins) {
        int[][] dp = new int[coins.length + 1][amount + 1];
        dp[coins.length][0] = 1;
        for (int index = coins.length - 1; index >= 0; --index) {
            for (int rest = 0; rest < amount + 1; ++rest) {
                // 我依赖我的下一行同位置开始从右往左等coins[index]间隔的数相加，但由于我左边间隔一个coins[index]的数已经计算了除了我下边的数的剩余数的和，我只需要把左边的加上下边的即可
                dp[index][rest] = dp[index + 1][rest];
                // 判断我左边有没有对应的
                if (rest - coins[index] >= 0) {
                    dp[index][rest] += dp[index][rest - coins[index]];
                }
            }
        }
        return dp[0][amount];
    }
    
}
```

> - ***Question 3: 面值和张数信息抽离***
>   - 利用哈希表，生成面值数组和对应的张数数组。

```java
class Solution {
    
    //词频统计类
    private static class Info {
        
        public int[] coins;
        public int[] zhangs;
        
        public Info(int[] coins, int[] zhangs) {
            this.coins = coins;
            this.zhangs = zhangs;
        }
        
    }
    
    public static Info getInfo(int[] money) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int m : money) {
            if (!map.containsKey(m)) {
                map.put(m, 1);
            } else {
                map.put(m, map.get(m) + 1);
            }
        }
        int[] coins = new int[map.size()];
        int[] zhangs = new int[map.size()];
        int index = 0;
        // 记忆，把键值对转成了视图
        // import java.util.Map.Entry;
        for (Entry<Integer, Integer> entry : map.entrySet()) {
            coins[index] = entry.getKey();
            zhangs[index] = entry.getValue();
            index++;
        }
        return new Info(coins, zhangs);
    }
    
}
```

> - ***Question 3: 暴力递归***
>   - `coins` 和 `zhangs` 分别为上面求出的面值数组和张数数组。

```java
class Solution {

    // 递归含义：在coins[index……]中拿到rest面额的钱的方法数，张数限制为zhangs[index]
    public static int recursion(int[] coins, int[] zhangs, int index, int rest) {
        if (index == coins.length) {
            return rest == 0 ? 1 : 0;
        }
        int ans = 0;
        for (int zhang = 0; zhang <= zhangs[index] && zhang * coins[index] <= rest; ++zhang) {
            ans += recursion(coins, zhangs, index + 1, rest - zhang * coins[index]);
        }
        return ans;
    }
    
}
```

> - ***Question 3: 动态规划***

```java
class Solution {

    public static int dp(int[] coins, int[] zhangs, int amount) {
        int[][] dp = new int[coins.length + 1][amount + 1];
        dp[coins.length][0] = 1;
        for (int index = coins.length - 1; index >= 0; --index) {
            for (int rest = 0; rest < amount + 1; ++rest) {
                int ans = 0;
                for (int zhang = 0; zhang <= zhangs[index] && zhang * coins[index] <= rest; ++zhang) {
                    ans += dp[index + 1][rest - zhang * coins[index]];
                }
                dp[index][rest] = ans;
            }
        }
        return dp[0][amount];
    }
    
}
```

> - ***Question 3: 动态规划 + 空间位置优化***
>   - 对于填格子时的优化更多了一步，因为题目限制了钱的张数的缘故，这个空间关系是双向进动的，不像 `Question 2` 中每个格子对于下一行的依赖是单向进动的。

```java
class Solution {
    
    public static int dp(int[] coins, int[] zhangs, int amount) {
        int[][] dp = new int[coins.length + 1][amount + 1];
        dp[coins.length][0] = 1;
        // 表的空间结构，其所依赖的下一行会随之移动
        //       -  +
        // -  -+ -+ +
        for (int index = coins.length - 1; index >= 0; --index) {
            for (int rest = 0; rest < amount + 1; ++rest) {
                dp[index][rest] = dp[index + 1][rest];
                if (rest - coins[index] >= 0) {
                    dp[index][rest] += dp[index][rest - coins[index]];
                }
                // 如果我直接加上我左边的，我会多加一个我不需要的，看看有没有再减去
                // zhangs[index] + 1就是下一行依赖的个数，视为间隔会找到多出的那个
                if (rest - coins[index] * (zhangs[index] + 1) >= 0) {
                    dp[index][rest] -= dp[index + 1][rest - coins[index] * (zhangs[index] + 1)];
                }
            }
        }
        return dp[0][amount];
    }
    
}
```

> - ***Question 4:***

```java
```

> - ***Question 4:***

```java
```

> - ***方法***

```java
```

> - ***方法***

```java
```

---

> ***last change: 2023/1/27***

---
