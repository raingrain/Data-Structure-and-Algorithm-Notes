# 扔鸡蛋问题

## [887. 鸡蛋掉落](https://leetcode.cn/problems/super-egg-drop/)

> - ***Question 1***
>   - 给你 `k` 枚相同的鸡蛋，并可以使用一栋从第 `1` 层到第 `n` 层共有 `n` 层楼的建筑（可以认为从建筑的第 `0` 层扔鸡蛋一定不会碎，总层数为 `0 ~ n` ）。
>   - 已知存在楼层 `f` ，满足 `0 <= f <= n` ，任何从高于 `f` 的楼层落下的鸡蛋都会碎，从 `f` 楼层或比它低的楼层落下的鸡蛋都不会破。
>   - 每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 `x` 扔下（满足 `1 <= x <= n` ）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中重复使用这枚鸡蛋。
>   - 老天一定会让你的运气最差，你不能使用二分。
>   - 请你计算并返回要确定 `f` 确切的值的最小操作次数是多少？
>   - ***examples:***
>     - `N=10, K=1` 返回 `10` 。因为只有 `1` 个鸡蛋，所以不得不从第 `1` 层开始一直试到第 `10` 层，在最差的情况下，即第 `10` 层是不会摔坏的最高层，最少也要扔 `10` 次。
>     - `N=3, K=2` 返回 `2` 。先在 `2` 层扔 `1` 个鸡蛋，如果碎了，试第 `1` 层，如果没碎，试第 `3` 层。
>     - `N=105, K=2` 返回 `14` 。第一个鸡蛋先在 `14` 层扔，碎了则用仅存的一个鸡蛋试 `1 ~ 13` 。若没碎，第一个鸡蛋继续在 `27` 层扔，碎了则用仅存的一个鸡蛋试 `15 ~ 26` 。若没碎，第一个鸡蛋继续在 `39` 层扔，碎了则用仅存的一个鸡蛋试 `28 ~ 38` 。若没碎，第一个鸡蛋继续在 `50` 层扔，碎了则用仅存的一个鸡蛋试 `40 ~ 49` 。若没碎，第一个鸡蛋继续在 `60` 层扔，碎了则用仅存的一个鸡蛋试 `51 ~ 59` 。若没碎，第一个鸡蛋继续在 `69` 层扔，碎了则用仅存的一个鸡蛋试 `61 ~ 68` 。若没碎，第一个鸡蛋继续在 `77` 层扔，碎了则用仅存的一个鸡蛋试 `70 ~ 76` 。若没碎，第一个鸡蛋继续在 `84` 层扔，碎了则用仅存的一个鸡蛋试 `78 ~ 83` 。若没碎，第一个鸡蛋继续在 `90` 层扔，碎了则用仅存的一个鸡蛋试 `85 ~ 89` 。若没碎，第一个鸡蛋继续在 `95` 层扔，碎了则用仅存的一个鸡蛋试 `91 ~ 94` 。若没碎，第一个鸡蛋继续在 `99` 层扔，碎了则用仅存的一个鸡蛋试 `96 ~ 98` 。若没碎，第一个鸡蛋继续在 `102` 层扔，碎了则用仅存的一个鸡蛋试 `100, 101` 。若没碎，第一个鸡蛋继续在 `104` 层扔，碎了则用仅存的一个鸡蛋试 `103` 。若没碎，第一个鸡蛋继续在 `105` 层扔，若到这一步还没碎，那么 `105` 便是结果。
>   - ***tips:***
>     - `1 <= k <= 100`
>     - `1 <= n <= 10^4`

## [1884. 鸡蛋掉落-两枚鸡蛋](https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/)

> - ***Question 2***
>   - 将 `Question 1` 中的鸡蛋数量限定为2个。
>   - ***tips:***
>     - `1 <= n <= 1000`

---

## *Java*

> - ***动态规划1***
>   - 定义 `dp[i][j]` 的含义为在所有的楼层中还剩下 `i` 层楼不确定从这 `i` 层楼往下扔鸡蛋会不会碎，还剩下 `j` 个鸡蛋可以扔，最少的试法需要扔多少次。
>   - 时间复杂度为 `O(n ^ 2 x k)` 。

```java
class Solution {
    
    // 双蛋
    public int twoEggDrop(int n) {
        return superEggDrop(2, n);
    }
    
    // k蛋
    public int superEggDrop(int k, int n) {
        if (k == 1) {
            return n;
        }
        return dp(k, n);
    }
    
    public int dp(int k, int n) {
        int[][] dp = new int[n + 1][k + 1];
        // 对于dp表来说，dp[0][j]表示有0层不确定，还有j个鸡蛋，显然不需要试，值为0
        // dp[i][0]表示没有鸡蛋，但还有楼层不确定，显然值也为0
        for (int i = 1; i < n + 1; ++i) {
            // 我只有一个鸡蛋怎么办，我只能从第一层开始，一层一层往上试
            // 这里的第一层指还剩下i层中的最底下那层
            dp[i][1] = i;
        }
        for (int j = 1; j < k + 1; ++j) {
            // 只有一层没确定，不管有多少个鸡蛋，仍一次即可
            dp[1][j] = 1;
        }
        // 前2行和前2列填过了
        for (int i = 2; i < n + 1; ++i) {
            for (int j = 2; j < k + 1; ++j) {
                int ans = Integer.MAX_VALUE;
                // testLevel指在剩下的不确定的i层中，第一次试从哪一层开始扔
                for (int testLevel = 1; testLevel <= i; ++testLevel) {
                    // 如果第一次扔碎了，我确定在剩下的这i层中，从testLevel层及其往上的所有层扔都会碎，那么我还剩testLevel层以下的testLevel-1层没试，鸡蛋还剩下j-1个，我去试试
                    // 如果第一次扔没碎，我确定在剩下的这i层中，testLevel层及其往下的所有层扔都不会碎，那么我还剩testLevel层以上的i-testLevel层没试，我去上面这些层扔鸡蛋，看看有没有碎的，鸡蛋因为没碎，还剩下j个
                    // 因为老天爷会让你运气最差，所以你在碎和不碎之间你肯定会获得让后续结果最坏的结果，先取max，再求题目要求的min
                    ans = Math.min(ans, Math.max(dp[testLevel - 1][j - 1], dp[i - testLevel][j]));
                }
                // 这个1次是你在testLevel层扔的那次
                dp[i][j] = ans + 1;
            }
        }
        return dp[n][k];
    }
    
}
```

> - ***动态规划1 + 四边形不等式优化枚举行为***
>   - 这是一个有枚举行为的二维动态规划。当两个可变参数固定一个，另外一个参数与答案之间存在单调性，且两个参数的单调性相反。鸡蛋的数量与所需次数呈负相关。楼层数量与所需次数呈正相关。符合四边形不等式使用条件。
>   - 观察发现一个普遍位置的格子依赖它的上方所有格子和这些格子的左邻居，有上凑右上。
>   - 为了使用上下限和右上限，我们大方向从上往下，每一行从右往左，对于最后一列的格子我们只找到上格子，只有下限，上限定为当前行对应的楼层数量即可。我们枚举的 `testLevel` 范围被缩小了。
>   - 时间复杂度为 `O(n x k)` 。

```java
class Solution {
    
    public int twoEggDrop(int n) {
        return superEggDrop(2, n);
    }
    
    public int superEggDrop(int k, int n) {
        if (k == 1) {
            return n;
        }
        return dp(k, n);
    }
    
    public int dp(int k, int n) {
        int[][] dp = new int[n + 1][k + 1];
        // best[i][j]表示在得到dp[i][j]的结果时最优尝试中第一次扔的楼层
        int[][] best = new int[n + 1][k + 1];
        for (int i = 1; i < n + 1; ++i) {
            dp[i][1] = i;
            // 只有一个鸡蛋，自底向上扔，肯定只能扔第一层
            best[i][1] = 1;
        }
        for (int j = 1; j < k + 1; ++j) {
            dp[1][j] = 1;
            // 不管有多少个鸡蛋，就一层给你扔
            best[1][j] = 1;
        }
        for (int i = 2; i < n + 1; ++i) {
            for (int j = k; j >= 2; --j) {
                int ans = Integer.MAX_VALUE;
                // 上边的格子是下限
                int down = best[i - 1][j];
                // 右边的格子是上限，注意最后一列
                int up = j == k ? i : best[i][j + 1];
                int bestChoose = 1;
                for (int testLevel = down; testLevel <= up; ++testLevel) {
                    int cur = Math.max(dp[testLevel - 1][j - 1], dp[i - testLevel][j]);
                    // 小于等于都行
                    if (cur <= ans) {
                        ans = cur;
                        // 更新最好选择位置
                        bestChoose = testLevel;
                    }
                }
                // 两个都更新
                best[i][j] = bestChoose;
                dp[i][j] = ans + 1;
            }
        }
        return dp[n][k];
    }
    
}
```

> - ***动态规划2 + 滚动数组***
>   - 以上方法解决的问题是 `n` 层楼有 `j` 个鸡蛋最少扔多少次。现在反过来看 `j` 个鸡蛋如果可以扔 `m` 次，最多可以解决多少层楼这个问题。根据上文实现的函数可以生成如下dp表， `dp[i][j]` 的意义为 `i` 个鸡蛋扔 `j` 次最多搞定的楼层数。
>   - 表的第 `0` 行，只有一个鸡蛋，只能扔 `j` 次的话，显然只能解决 `j` 层楼。
>   - 表的第一列，我们假设次数从 `0` 开始，那么第 `0` 列都是 `0` ，不扔解决啥问题。
>   - 我们注意到表的列数是不确定的，没错！我们使用滚动数组，当 `dp[i][j]` 的值大于等于题目要求的楼层时，我们就可以结束运算，返回当前对应的列号（次数）。
>   - 对于普遍位置有 `dp[i][j] == dp[i][j-1] + dp[i-1][j-1] + 1` 。如何理解这个公式呢？假设 `i` 个鸡蛋扔 `j` 次最多搞定 `m` 层楼，“搞定最多”说明每次扔的位置都是最优的且鸡蛋肯定够用的情况，假设第 `1` 个鸡蛋扔在 `a` 层楼是最优的尝试：
>     - 如果第 `1` 个鸡蛋已碎，那就向下，看 `i - 1` 个鸡蛋扔 `j - 1` 次最多搞定多少层楼。
>     - 如果第 `1` 个鸡蛋没碎，那就向上，看 `i` 个鸡蛋扔 `j - 1` 次最多搞定多少层楼。
>     - `a` 层楼本身也是被搞定的 `1` 层。
>   - 三个步骤的总楼层数就是 `i` 个鸡蛋扔 `j` 次最多搞定的楼层数，dp表的生成过程极为简单，同时数值增长极快。原始问题可以用dp表得到很好的解决。
>   - 此外还有一个特别重要的优化，我们知道 `N` 层楼完全用二分的方式扔 `log2N + 1` 次就可以确定哪层楼是会碎的最低楼层。所以当鸡蛋数 `k` 大于 `log2N + 1` 时，我们就可以直接返回 `logN + 1` 。
>   - 如果鸡蛋数为 `K` 、楼层数为 `N` ，最终的结果为 `M` 次，那么最优解的时间复杂度为 `O(K x M)` ，在鸡蛋数大于 `logN + 1` 时，时间复杂度为 `O(logN)` 。在只有一个鸡蛋的时候， `K x M` 等于 `N` ，在其他情况下， `K x M` 比 `N` 要小得多。

```java
class Solution {
    
    public int twoEggDrop(int n) {
        return superEggDrop(2, n);
    }
    
    public int superEggDrop(int k, int n) {
        if (k == 1) {
            return n;
        }
        return dp(k, n);
    }
    
    public int dp(int k, int n) {
        if (k >= n) {
            // 最优解
            return log2N(n) + 1;
        }
        int[] dp = new int[k];
        int ans = 0;
        while (true) {
            ++ans;
            int leftUp = 0;
            for (int i = 0; i < dp.length; ++i) {
                int left = dp[i];
                dp[i] = left + leftUp + 1;
                leftUp = left;
                if (dp[i] >= n) {
                    return ans;
                }
            }
        }
    }
    
    // 求log2N
    public int log2N(int n) {
        int ans = -1;
        while (n != 0) {
            ++ans;
            n >>>= 1;
        }
        return ans;
    }
    
}
```
