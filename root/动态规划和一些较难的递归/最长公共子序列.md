# 最长公共子序列

## [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

## [剑指 Offer II 095. 最长公共子序列](https://leetcode.cn/problems/qJnOS7/)

> - ***Question***
>   - 给定两个字符串 `text1` 和 `text2` ，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 `0` 。
>   - 一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
>   - 两个字符串的公共子序列是这两个字符串所共同拥有的子序列。
>   - ***tips:***
>     - `1 <= text1.length, text2.length <= 1000`
>     - `text1` 和 `text2` 仅由小写英文字符组成

---

## *Java*

> - ***暴力递归***
>   - 样本对应模型，超时。

```java
class Solution {
    
    public int longestCommonSubsequence(String text1, String text2) {
        /*if (text1 == null || text2 == null || text1.length() == 0 || text2.length() == 0) {
            return 0;
        }*/
        char[] str1 = text1.toCharArray();
        char[] str2 = text2.toCharArray();
        return recursion(str1, str2, str1.length - 1, str2.length - 1);
    }
    
    // 可变参数为i和j，变化范围为0 ~ str1.length - 1和0 ~ str2.length - 1
    // 递归含义：获取str1[0-i]和str2[0-j]上的最长公共子序列的长度
    public int recursion(char[] str1, char[] str2, int i, int j) {
        if (i == 0 && j == 0) {
            // 第一个边界条件，两个字符串从右往左遍历同时来到最左，0位置字符相同可以纳入公共子序列中
            return str1[0] == str2[0] ? 1 : 0;
        } else if (i == 0) {
            // 如果i的最左与str2[j]相同，那么返回1，且str1遍历完了，递归结束
            return str1[0] == str2[j] ? 1 : recursion(str1, str2, 0, j - 1);
        } else if (j == 0) {
            // 如果j的最左与str1[i]相同，那么返回1，且str2遍历完了，递归结束
            return str1[i] == str2[0] ? 1 : recursion(str1, str2, ij - 1, 0);
        } else {
            // 一定不选i，考虑j，即公共子序列一定以j位置的字符做结尾，但不一定以i位置的字符做结尾
            int p1 = recursion(str1, str2, i, j - 1);
            // 考虑i，一定不选j，即公共子序列一定以i位置的字符做结尾，但不一定以j位置的字符做结尾
            int p2 = recursion(str1, str2, i - 1, j);
            // p1和p2的交集是即不以i位置也不以j位置的字符做结尾，没有独立判断一定不选i但一定选j的情况，是因为如果要确定这种情况 就需要遍历str1看看有没有str2[j]，即判断j能不能成为公共子序列中的一员
            // 一定选i，一定选j
            int p3 = str1[i] == str2[j] ? recursion(str1, str2, i - 1, j - 1) + 1 : 0;
            // 最长即最大
            return Math.max(p1, Math.max(p2, p3));
        }
    }
    
}
```

> - ***动态规划***

```java
class Solution {
    
    public int longestCommonSubsequence(String text1, String text2) {
        /*if (text1 == null || text2 == null || text1.length() == 0 || text2.length() == 0) {
            return 0;
        }*/
        return dp(text1.toCharArray(), text2.toCharArray());
    }
    
    public int dp(char[] str1, char[] str2) {
        int[][] dp = new int[str1.length][str2.length];
        dp[0][0] = str1[0] == str2[0] ? 1 : 0;
        // 先填第一行
        for (int j = 1; j < str2.length; ++j) {
            dp[0][j] = str1[0] == str2[j] ? 1 : dp[0][j - 1];
        }
        // 再填第一列
        for (int i = 1; i < str1.length; ++i) {
            dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0];
        }
        // 从第二行，第二列开始，先从左往右，再从上往下填
        for (int i = 1; i < str1.length; ++i) {
            for (int j = 1; j < str2.length; ++j) {
                int p1 = dp[i][j - 1];
                int p2 = dp[i - 1][j];
                int p3 = str1[i] == str2[j] ? dp[i - 1][j - 1] + 1 : 0;
                dp[i][j] = Math.max(p1, Math.max(p2, p3));
            }
        }
        return dp[str1.length - 1][str2.length - 1];
    }
    
}
```

> - ***动态规划 + 滚动数组优化***

```java
class Solution {
    
    public int longestCommonSubsequence(String text1, String text2) {
        /*if (text1 == null || text2 == null || text1.length() == 0 || text2.length() == 0) {
            return 0;
        }*/
        return dp(text1.toCharArray(), text2.toCharArray());
    }
    
    public int dp(char[] str1, char[] str2) {
        int[] dp = new int[str2.length];
        dp[0] = str1[0] == str2[0] ? 1 : 0;
        // 先填第一行
        for (int j = 1; j < str2.length; ++j) {
            dp[j] = str1[0] == str2[j] ? 1 : dp[j - 1];
        }
        for (int i = 1; i < str1.length; ++i) {
            // 记录左上角的值
            int leftUp = dp[0];
            // 先填第一列
            dp[0] = str1[i] == str2[0] ? 1 : dp[0];
            for (int j = 1; j < str2.length; ++j) {
                // 左
                int p1 = dp[j - 1];
                // 上
                int p2 = dp[j];
                // 左上
                int p3 = str1[i] == str2[j] ? leftUp + 1 : 0;
                // 当前位置没更新前其实是下一个要计算的位置的左上角，更新左上角后再更新当前位置
                leftUp = dp[j];
                dp[j] = Math.max(p1, Math.max(p2, p3));
            }
        }
        return dp[str2.length - 1];
    }
    
}
```

---

> ***last change: 2023/1/25***

---
